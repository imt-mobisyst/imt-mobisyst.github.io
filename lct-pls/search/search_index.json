{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Lecture: Python Libs for Sciences","title":"Lecture intro."},{"location":"#lecture-python-libs-for-sciences","text":"","title":"Lecture: Python Libs for Sciences"},{"location":"basis-01-exo/","text":"System and Python Basis - Exercises 1. Exercise: Search for a User's Groups Create a script returning the names (print) of all groups associated with the user. Always process in an incremental way: Decompose the module to develop Implement it step by step Test the solution at each step Initialize your project: Make a new directory : python-data-science for instance. Edit a new Python file: search-group.py with gedit for instance. Test a hello-world script python3 search-group.py Load ressources Open a file and read-it line by line Apply it to /etc/passwd then /etc/group I do not know how to open a file ? search the web... w3schools Search for a specific word (user name) in a lines Detect for bob user in lines Print only lines with bob inside There is a lot of string methods in Python (for instance, still in W3School ) and one of them seems very interesting: find() . Another one split() allows for decomposing a long string regarding a separator character. Reduce to user's Groups Select only the primary group name in /etc/passwd file for the user bob . Select each group name in /etc/groups , each time bob is present. 2. Exercise: Script as a shell command The goal is to transform search-group.py code into a shell command, executable like anyother. Get user name as a command argument For that, use the sys.argv from the Python package sys . This variable provides the list of the command line arguments. In the Shell We aim to call our program by masking the need for the Python3 interpreter. Like that: search-user bob Version 1 : By using an alias (typically alias search-user='python3 search-user.py' ) Version 2 : By using a shebang , to identify the interpreter inside the Python script, and by setting the script executable chmod +x . Anywhere The script is only accessible from the current directory. Resolve this problem Version 1 : Modify the alias definition with a global path to the script. Version 2 : Add the current directory to the PATH variable ( export PATH=$PATH:~/path/to/ ) Anytime The alais or exports are not available in a new shell. To make them automatically defined, you may add the appropriate lines to your local .bashrc file. This file allows the users to tune their bash shell at start time. Exercise: Increased Command split() is restrictive much for extracting some element from a string ? Take a look at Regular Expression in Python w3school Handle bugs (no user name in arguments, ...) Add options to your command: --help or -h for help, -i for printing group ids, -t to test if the user is in a specific group, ... Make a new directory : python-data-science for instance. Edit a new Python file: search-group.py with gedit for instance. Test a hello-world script python3 search-group.py","title":"First exos"},{"location":"basis-01-exo/#system-and-python-basis-exercises","text":"","title":"System and Python Basis - Exercises"},{"location":"basis-01-exo/#1-exercise-search-for-a-users-groups","text":"Create a script returning the names (print) of all groups associated with the user. Always process in an incremental way: Decompose the module to develop Implement it step by step Test the solution at each step","title":"1. Exercise: Search for a User's Groups"},{"location":"basis-01-exo/#initialize-your-project","text":"Make a new directory : python-data-science for instance. Edit a new Python file: search-group.py with gedit for instance. Test a hello-world script python3 search-group.py","title":"Initialize your project:"},{"location":"basis-01-exo/#load-ressources","text":"Open a file and read-it line by line Apply it to /etc/passwd then /etc/group I do not know how to open a file ? search the web... w3schools","title":"Load ressources"},{"location":"basis-01-exo/#search-for-a-specific-word-user-name-in-a-lines","text":"Detect for bob user in lines Print only lines with bob inside There is a lot of string methods in Python (for instance, still in W3School ) and one of them seems very interesting: find() . Another one split() allows for decomposing a long string regarding a separator character.","title":"Search for a specific word (user name) in a lines"},{"location":"basis-01-exo/#reduce-to-users-groups","text":"Select only the primary group name in /etc/passwd file for the user bob . Select each group name in /etc/groups , each time bob is present.","title":"Reduce to user's Groups"},{"location":"basis-01-exo/#2-exercise-script-as-a-shell-command","text":"The goal is to transform search-group.py code into a shell command, executable like anyother.","title":"2. Exercise: Script as a shell command"},{"location":"basis-01-exo/#get-user-name-as-a-command-argument","text":"For that, use the sys.argv from the Python package sys . This variable provides the list of the command line arguments.","title":"Get user name as a command argument"},{"location":"basis-01-exo/#in-the-shell","text":"We aim to call our program by masking the need for the Python3 interpreter. Like that: search-user bob Version 1 : By using an alias (typically alias search-user='python3 search-user.py' ) Version 2 : By using a shebang , to identify the interpreter inside the Python script, and by setting the script executable chmod +x .","title":"In the Shell"},{"location":"basis-01-exo/#anywhere","text":"The script is only accessible from the current directory. Resolve this problem Version 1 : Modify the alias definition with a global path to the script. Version 2 : Add the current directory to the PATH variable ( export PATH=$PATH:~/path/to/ )","title":"Anywhere"},{"location":"basis-01-exo/#anytime","text":"The alais or exports are not available in a new shell. To make them automatically defined, you may add the appropriate lines to your local .bashrc file. This file allows the users to tune their bash shell at start time.","title":"Anytime"},{"location":"basis-01-exo/#exercise-increased-command","text":"split() is restrictive much for extracting some element from a string ? Take a look at Regular Expression in Python w3school Handle bugs (no user name in arguments, ...) Add options to your command: --help or -h for help, -i for printing group ids, -t to test if the user is in a specific group, ... Make a new directory : python-data-science for instance. Edit a new Python file: search-group.py with gedit for instance. Test a hello-world script python3 search-group.py","title":"Exercise: Increased Command"},{"location":"basis-01-system/","text":"The basics: The computer and the program 1. At the beginning was the Shell : A computer program that exposes an operating system's services to a human user or other programs. ( Wikipedia - Sep. 2023 ) (also named a terminal ) Some Vocabulary: Prompt : A command prompt (or just prompt) state in the command-line interface indicating readiness to accept commands. Command : an instruction received via an external interface that directs the behavior of a computer program. In other terms, a call to a program with potentially specific attributes. 2. First BASH Commands. Bash is the most popular Unix/Linux shell, available by default on most Linux distributions. It is also natively supported on Apple, and versions of Bash can be installed with tools like MinGW on Windows However, most of the commands presented here exist in other Shell or have some equivalents. 2.a. The File System First of all, some commands allow a user to navigate in file systems et interact with it. ls - list directory elements cd - change directory cat - read all a text file more - read a text file step by step touch - touch a resource (create it) nano - edit a text file rm - remove a file (permanently) mkdir - create (make) a directory rmdir - remove a directory mv - move a resource cp - copy-paste a file clear - clear your promt Most of this commands manipulate paths - a description of where to find a resource on the computer -. / - the root directory in Linux system - example: du /bin/bash (du - estimate file space usage) . - the current directory - example: mkdir ./workspace .. - the parent directory - example: cd ../../media ~ - the user directory (home) - example: cd ~/Documents CApitAl Letters maTer - example: cd ~/Documents \\(\\neq\\) cd ~/documents 2.b. Mastering Commands Most of the commands accept arguments and options. With a simplistic vision, the argument gives a target to the command execution, while options permit the user to change the context execution of the command. Classical syntax: command --option -o argument - example: ls -a ~ Some commands permit manipulating the command collection. man - command and library manual - example: man cp apropos - search in the manuals - example: apropos search whereis - find the location of a resource - example: whereis python3 alias - create our own command - example: alias listall=\"ls -a\" 2.c. Some triks : tabulation : auto-complete the command line or list the possibilities. !xx : run again the last command starting with xx . ctrl-r : search for a command in command history. Q : quit a running program (in most programs). ctr-c : terminate a running program. ~/.bashrc : file: user configuration routine. 3. Users session On Linux, users are clearly identified everywhere. All resources have owners, and users can be limited in their capacities on the system. Users can be artificially set, they are not necessarily real human beings. 3.a. session A session is an active connection to a system or program. who - list the open session in a computer su : start a new session as a specific user - example: su bob ssh - open a session in a distant computer following the ssh protocol A user session is associated with an environment. I.e. a computer system or set of systems in which a computer program or software component is deployed and executed ( Wikipedia Sept. 2023 ). env - list the environment variable. $ - access a variable - example: echo $PATH $PATH - list of all directories where bash search the commands. $SHELL - the current shell interpreter. $USER - the user name. export - create a new variable - example: export MYBIN=~/bin ~/.bashrc (file): user configuration commands. 3.b. User, Group and Rules Users are structured with groups . Users as groups have a name and a number A user is defined with a primary group , its main group, but a group can include several users. The files /etc/passwd and /etc/group record that information, among others. List them with cat for example ( cat /etc/passwd and cat /etc/group ). Specific access is associated to each resource on the computer with r : read \\(\\quad\\) w : write \\(\\quad\\) x : executed/open. The triple authorization can be different for the user owner, the group owner, or all the others. List command with the -l option gives ownership and authorization information, among others. For example, with ls -l /etc Manipulate the owner and authorizations: chmod : change authorizations - Examples: chmod +x aFile - add x authorization on aFile chmod 752 aFile - set authorization on aFile on a binary style chown : change the owner sudo : excute a command as a root user (administrator) if granted - example sudo gedit /etc/passwd . 4. The Processes Finally, the Operating System (OS) is mainly a process manager... An OS offers an environment to create and execute programs. Typically, the language C is first developed in parallel to Unix to provide a powerful language to the OS, and to use it for the OS core processes. Today, systems have evolved significantly and allow complex architecture with several processes running in parallel and potentially in virtual machines. Similarly to ls , ps list the local processes (ie. the children processes of the bash shell). For instance: gedit aFile.txt & ps Here, & permits to get the prompt back after starting gedit . As for other commands, ps accepts options, for instance, adding -e lists all the processes on the machine. For managing processes, OS attaches some elements to each one: the PID (Process IDentifier), a parent process, an owner, a name, ... Other command : top - interactive process monitoring ( Q to quit ) (quite similar to ps , but interactive and constantly updated) kill - sent a signal to a process - Examples: kill 19482 - send TERM signal to process 19482 ; kill -s KILL 19482 - send KILL signal to process 19482 Codes, Programs and Scripts Codes : Sequence of written instruction text format according to a given programming language. Programs : Executable binary on a OS Specific to the OS (and potentially to the hardware) Generally compiled codes (example with C language compiled with gcc ). Scripts : Interpretable pieces of code by a program. Typically, Python is a scripting language. file: hello.py 5. Python Programming Languages Python is a high level programming language. Its allows for abstracted data structures, includes core tools like dynamic type , garbage colector , Object-Oriented Programming (OOP) and a lot more with a large collection of libraries. The language is interpreted, and python3 designs the programming language but also the interpreter process ( cpython ), allowing reading and executing Python instructions. Code source on github.com - 63.5% Python / 34.6% C Minimale python script: print('hello world') Then in a shell: python3 hello.py Python in short: Rich language capabilities (it is possible to do complex things) Concise language (complex things require few codes) Very rich community libraries (most of the complex things are already implemented) Interpretable (the code is mostly OS independent) Use a virtual machine (including Garbage Collector) Not natively efficient (but compatible with C and C++ libs) 4.a Sequential Instructions Python is structured with sequential instructions: # Some comments... a= 1 # - Asignment of a new integer variable b= a + 48.4 # - Asignment of a new floating point variable # as the result of the instruction: a + 48.4 aString= \"Hello\" # - Assignment of a new string variable (list of characters) print( aString ) # - Call to the function print with aString as one parameter result= aString.search('e') # - Call to the method search on the aString instance # with a parameter 'e' It allows for function definition. def myWonderfullFunction( aFirstIntergerPaprameter, aSecondIntergerParameters ): intergerSum= aFirstIntergerPaprameter + aSecondIntergerParameters return intergerSum a= 2 b= myWonderfullFunction( a, 40 ) print( \"Result: \" + str(b) ) To notice: Block separation is delimited with space or tabulation indentation. Functions need to be defined prior to be used. 4.b loop control Loops allow for repeating an instruction sequence until a specific state is reached ( while ) or by visiting a collection of objects ( for ). The while instruction ( WHILE condition DO something ) is the simplest available loop control: b= 0 while b <= 40 : b+= 2 print( \"Result: \" + str(b) ) The for instruction allows for visiting each element of an iterable collection, for instance, a list. aList= [2, 10, 18, 4, 8] b= 0 for value in aList : b+= value print( \"Result: \" + str(b) ) 4.c Going further... It is not the purpose here, to provide an entire course on Python . There are huge resources on the internet, both more complete and well organized, starting with the official Python documentation https://docs.python.org/3/ . We highly recommend searching the web to increase your knowledge. In this jungle, the w3schools certainly offers the best learning experience. You can start, for instance, with Python lists and Python dictionaries , the two most used data structures in Python. Finally, complementary modules / packages can be associated to the code with the import instruction. Typically sys package provides some interfaces with the system. import sys print( \"System platform: \"+ str(sys.platform) )","title":"OS & language"},{"location":"basis-01-system/#the-basics-the-computer-and-the-program","text":"","title":"The basics: The computer and the program"},{"location":"basis-01-system/#1-at-the-beginning-was-the-shell","text":"A computer program that exposes an operating system's services to a human user or other programs. ( Wikipedia - Sep. 2023 ) (also named a terminal )","title":"1. At the beginning was the Shell :"},{"location":"basis-01-system/#some-vocabulary","text":"Prompt : A command prompt (or just prompt) state in the command-line interface indicating readiness to accept commands. Command : an instruction received via an external interface that directs the behavior of a computer program. In other terms, a call to a program with potentially specific attributes.","title":"Some Vocabulary:"},{"location":"basis-01-system/#2-first-bash-commands","text":"Bash is the most popular Unix/Linux shell, available by default on most Linux distributions. It is also natively supported on Apple, and versions of Bash can be installed with tools like MinGW on Windows However, most of the commands presented here exist in other Shell or have some equivalents.","title":"2. First BASH Commands."},{"location":"basis-01-system/#2a-the-file-system","text":"First of all, some commands allow a user to navigate in file systems et interact with it. ls - list directory elements cd - change directory cat - read all a text file more - read a text file step by step touch - touch a resource (create it) nano - edit a text file rm - remove a file (permanently) mkdir - create (make) a directory rmdir - remove a directory mv - move a resource cp - copy-paste a file clear - clear your promt Most of this commands manipulate paths - a description of where to find a resource on the computer -. / - the root directory in Linux system - example: du /bin/bash (du - estimate file space usage) . - the current directory - example: mkdir ./workspace .. - the parent directory - example: cd ../../media ~ - the user directory (home) - example: cd ~/Documents CApitAl Letters maTer - example: cd ~/Documents \\(\\neq\\) cd ~/documents","title":"2.a. The File System"},{"location":"basis-01-system/#2b-mastering-commands","text":"Most of the commands accept arguments and options. With a simplistic vision, the argument gives a target to the command execution, while options permit the user to change the context execution of the command. Classical syntax: command --option -o argument - example: ls -a ~ Some commands permit manipulating the command collection. man - command and library manual - example: man cp apropos - search in the manuals - example: apropos search whereis - find the location of a resource - example: whereis python3 alias - create our own command - example: alias listall=\"ls -a\"","title":"2.b. Mastering Commands"},{"location":"basis-01-system/#2c-some-triks","text":"tabulation : auto-complete the command line or list the possibilities. !xx : run again the last command starting with xx . ctrl-r : search for a command in command history. Q : quit a running program (in most programs). ctr-c : terminate a running program. ~/.bashrc : file: user configuration routine.","title":"2.c. Some triks :"},{"location":"basis-01-system/#3-users-session","text":"On Linux, users are clearly identified everywhere. All resources have owners, and users can be limited in their capacities on the system. Users can be artificially set, they are not necessarily real human beings.","title":"3. Users session"},{"location":"basis-01-system/#3a-session","text":"A session is an active connection to a system or program. who - list the open session in a computer su : start a new session as a specific user - example: su bob ssh - open a session in a distant computer following the ssh protocol A user session is associated with an environment. I.e. a computer system or set of systems in which a computer program or software component is deployed and executed ( Wikipedia Sept. 2023 ). env - list the environment variable. $ - access a variable - example: echo $PATH $PATH - list of all directories where bash search the commands. $SHELL - the current shell interpreter. $USER - the user name. export - create a new variable - example: export MYBIN=~/bin ~/.bashrc (file): user configuration commands.","title":"3.a. session"},{"location":"basis-01-system/#3b-user-group-and-rules","text":"Users are structured with groups . Users as groups have a name and a number A user is defined with a primary group , its main group, but a group can include several users. The files /etc/passwd and /etc/group record that information, among others. List them with cat for example ( cat /etc/passwd and cat /etc/group ). Specific access is associated to each resource on the computer with r : read \\(\\quad\\) w : write \\(\\quad\\) x : executed/open. The triple authorization can be different for the user owner, the group owner, or all the others. List command with the -l option gives ownership and authorization information, among others. For example, with ls -l /etc Manipulate the owner and authorizations: chmod : change authorizations - Examples: chmod +x aFile - add x authorization on aFile chmod 752 aFile - set authorization on aFile on a binary style chown : change the owner sudo : excute a command as a root user (administrator) if granted - example sudo gedit /etc/passwd .","title":"3.b. User, Group and Rules"},{"location":"basis-01-system/#4-the-processes","text":"Finally, the Operating System (OS) is mainly a process manager... An OS offers an environment to create and execute programs. Typically, the language C is first developed in parallel to Unix to provide a powerful language to the OS, and to use it for the OS core processes. Today, systems have evolved significantly and allow complex architecture with several processes running in parallel and potentially in virtual machines. Similarly to ls , ps list the local processes (ie. the children processes of the bash shell). For instance: gedit aFile.txt & ps Here, & permits to get the prompt back after starting gedit . As for other commands, ps accepts options, for instance, adding -e lists all the processes on the machine. For managing processes, OS attaches some elements to each one: the PID (Process IDentifier), a parent process, an owner, a name, ... Other command : top - interactive process monitoring ( Q to quit ) (quite similar to ps , but interactive and constantly updated) kill - sent a signal to a process - Examples: kill 19482 - send TERM signal to process 19482 ; kill -s KILL 19482 - send KILL signal to process 19482","title":"4. The Processes"},{"location":"basis-01-system/#codes-programs-and-scripts","text":"Codes : Sequence of written instruction text format according to a given programming language. Programs : Executable binary on a OS Specific to the OS (and potentially to the hardware) Generally compiled codes (example with C language compiled with gcc ). Scripts : Interpretable pieces of code by a program. Typically, Python is a scripting language. file: hello.py","title":"Codes, Programs and Scripts"},{"location":"basis-01-system/#5-python-programming-languages","text":"Python is a high level programming language. Its allows for abstracted data structures, includes core tools like dynamic type , garbage colector , Object-Oriented Programming (OOP) and a lot more with a large collection of libraries. The language is interpreted, and python3 designs the programming language but also the interpreter process ( cpython ), allowing reading and executing Python instructions. Code source on github.com - 63.5% Python / 34.6% C Minimale python script: print('hello world') Then in a shell: python3 hello.py Python in short: Rich language capabilities (it is possible to do complex things) Concise language (complex things require few codes) Very rich community libraries (most of the complex things are already implemented) Interpretable (the code is mostly OS independent) Use a virtual machine (including Garbage Collector) Not natively efficient (but compatible with C and C++ libs)","title":"5. Python Programming Languages"},{"location":"basis-01-system/#4a-sequential-instructions","text":"Python is structured with sequential instructions: # Some comments... a= 1 # - Asignment of a new integer variable b= a + 48.4 # - Asignment of a new floating point variable # as the result of the instruction: a + 48.4 aString= \"Hello\" # - Assignment of a new string variable (list of characters) print( aString ) # - Call to the function print with aString as one parameter result= aString.search('e') # - Call to the method search on the aString instance # with a parameter 'e' It allows for function definition. def myWonderfullFunction( aFirstIntergerPaprameter, aSecondIntergerParameters ): intergerSum= aFirstIntergerPaprameter + aSecondIntergerParameters return intergerSum a= 2 b= myWonderfullFunction( a, 40 ) print( \"Result: \" + str(b) ) To notice: Block separation is delimited with space or tabulation indentation. Functions need to be defined prior to be used.","title":"4.a Sequential Instructions"},{"location":"basis-01-system/#4b-loop-control","text":"Loops allow for repeating an instruction sequence until a specific state is reached ( while ) or by visiting a collection of objects ( for ). The while instruction ( WHILE condition DO something ) is the simplest available loop control: b= 0 while b <= 40 : b+= 2 print( \"Result: \" + str(b) ) The for instruction allows for visiting each element of an iterable collection, for instance, a list. aList= [2, 10, 18, 4, 8] b= 0 for value in aList : b+= value print( \"Result: \" + str(b) )","title":"4.b loop control"},{"location":"basis-01-system/#4c-going-further","text":"It is not the purpose here, to provide an entire course on Python . There are huge resources on the internet, both more complete and well organized, starting with the official Python documentation https://docs.python.org/3/ . We highly recommend searching the web to increase your knowledge. In this jungle, the w3schools certainly offers the best learning experience. You can start, for instance, with Python lists and Python dictionaries , the two most used data structures in Python. Finally, complementary modules / packages can be associated to the code with the import instruction. Typically sys package provides some interfaces with the system. import sys print( \"System platform: \"+ str(sys.platform) )","title":"4.c Going further..."},{"location":"basis-02-poo/","text":"Object-Oriented Programming This tutorial revisits OOP concepts, by presenting them in Python. In a second part, an exercise is proposed to create a toolbox for MP3 collection management. All the proposed pieces of code should be tested in a script.py . 1. Object-Oriented Programming (OOP) in Python Playing with class, and the main concepts of OOP in Python . 1.a. Structuring element together First a class can be reduced to a collection of class attributes and functions. # Definition: class MyObjectType : world= \"world\" def function1() : return \"hello\" def function2() : return MyObjectType.world # Use: hello= MyObjectType.function1() print( hello + ' ' + MyObjectType.function2() ) To notice the indentations that state what is inside a class with a new level of indentation for instructions of the class's function. In this example, MyObjectType is a class with one attribute ( world ) and two functions ( function1() , function2() ). 1.b. Class Instance The main feature of class is the capacity to instantiate objects ( class instances ). An instance of a class is an object defined as a specific type. It is possible to associate attributes with an instance. In this case, instance-attribute values can be different for different instances of the same class (by opposition to class-attributes). # Definition: class MyObjectType : class_word= \"hello\" # A class attribute # Use: anInstance= MyObjectType() # Instanciate a MyObjectType object anInstance.instance_word= \"world\" # an instance attribute aSecondInstance= MyObjectType() aSecondInstance.instance_word= \"nobody\" assert( type(anInstance) is MyObjectType ) print( anInstance.class_word + ' ' + anInstance.instance_word ) At this point, anInstance.class_word is MyObjectType.class_word , and for no confusion, you should use MyObjectType.class_word to manipulate this attribut. Another good way to manipulate a class attribute: type(anInstance).classAttribut . Typically, nasty manipulation of class-attributes can transform them into instance attributes for specific instances that generate failure, difficult to debug... As in this example : # Definition: class MyObjectType : classAttribut= \"Void\" # Use: anInstance= MyObjectType() MyObjectType.classAttribut= \"Hello\" print( anInstance.classAttribut ) anInstance.classAttribut= \"World\" # I should not do that... print( MyObjectType.classAttribut ) MyObjectType.classAttribut= \"Hmmm\" print( anInstance.classAttribut + \" - \" + MyObjectType.classAttribut ) 1.c. Methods The strength of OOP relies on the instances that define a context for the executions of functions associated to the class. A function associated to an instance is named a METHOD . In Python , a method is a class function where the instance is explicit as the first parameter. A convention supposes that this instance is named self . # Definition: class MyObjectType : def method(self) : return 42 # Use: anInstance= MyObjectType() # Instanciate a MyObjectType v1= anInstance.method() v2= MyObjectType.method(anInstance) if v1 == v2 : print( \"Hello World\" ) print( f\"{MyObjectType.method}\\nvs {anInstance.method}\") As in this example, in Python a method can be called directly on an instance ( v1 ) or as a class function ( v2 ). In the first case, the method is bound to an instance : # Definition: class MyObjectType : def method(self) : return 42 anInstance= MyObjectType() print( f\"{MyObjectType.method}\\nvs\\n{anInstance.method} ({anInstance})\") As a result, in Python , a method with \\(3\\) arguments is defined by a function of \\(4\\) arguments. def aMethod(self, argument1, argument2, argument3) : pass 2. Built-in Python Python defines numerous tools natively. Many of those tools rely on functions/methods associated with types. There are named built-in functions . Those functions can be redefined (overridden) to attach a specific behavior to developer types (classes). 2.a. Built-in Class First of them are the built-in functions defined in Python objects: __init__(self) : Instance initialization, called at instance construction. __del__(self) : Instance destruction, called when a instance is deleted. __str__(self) : Transform an instance in a string # Definition: class MyObjectType : def __init__(self): print('Initialization') def __del__(self): print('Destruction') def __str__(self): return \"> MyObjectType::instance <\" # Use: anInstance= MyObjectType() print( anInstance ) To notice that it is possible to change the number of parameters in __init__ to generate a constructor over parameters. In general, all the instance attributes are created in the __init__ method. But it is not mandatory (in fact, in Python, the number and definition of instance attributes are dynamic). It is also possible to call the parent method when overriding with super . # Definition: class MyObjectType : def __init__(self): print('Initialization') def __del__(self): print('Destruction') def __str__(self): return \"> MyObjectType::instance <\" # Definition: class ObjectSpecific(MyObjectType) : def __init__(self, aNumber): super(MyObjectType, self)._init__(self) self._aNumber= aNumber def __str__(self): return f\"> MyObjectType::instance-{self._aNumber} <\" # Use: anInstance= MyObjectType(42) print( anInstance ) 2.b. Good practices. As we already see, several rules are more good practices than language constraints. The current instance, context for a method execution, is always named self . __init__ method (if defined) is your first method. Initialize your instance attributes into the __init__ method. Attribute names start with _ . Class names start with an Uppercase letter. etc. Most of those conventions are presented in the style guide for Python code 2.c. Operators. Finally, most of the operator can be redefined based on built-in function. For a complete list with other type built-in functions, see docs.python.org An example with the addition: class Vector : def __init__(self, x, y): self._x= x self._y= y def __add__(self, another): return Vector( self._x+another._x, self._y+another._y ) def __str__(self): return f\"({self._x}, {self._y})\" # Use: a= Vector( 10.7, 8.0 ) b= Vector( -2.1, 34.0 ) print( f\"{a} + {b} = {a+b}\" ) 3. Let's Play We now have an idea of what OOP is capable of in Python . The exercise here is to put those notions in music. 3.a Read a Mp3 sound As a first exercie we want a class representing a song. First, an exploration on internet showed us the librairie: playsound3 allowing us for play mp3 music. This example loads a music song and play it : import time from playsound3 import playsound # You can play sounds in the background sound = playsound(\"./song.mp3\", block=False) # and check if they are still playing if sound.is_alive() : print(\"Sound is playing!\") time.sleep( 5.0 ) # and stop them whenever you like. sound.stop() So as a first result, we aim to have a class ( Song for instance) with methods to load a music file and to play it. Something like this: class song : # To implement ... asong= Song() asong.load(\"./song.mp3\") aSound.play() 3.b Accessor Our Song class defines a few attributes for an instance: a title, an artist name, an album name, and the number of tracks in the album. First, we want a constructor that defines all of these attributes. Then we ask for an accessor method for each of these attributes. class song : # To implement ... asong= Song(\"Rodriguez\", \"Can't Get Away\", \"Searching for Sugar Man\", 7 ) asong.load(\"./song.mp3\") print( f\"{asong.artist()} - {asong.album()} {asong.track()} - {asong.title()}\" ) asound.play() In fact, we will prefer to get metadata from the file directly when loading it. To do that we can count on eyeD3 Python library ( documentation ). Here's a piece of code to help in this mission: import eyed3 audiofile = eyed3.load(\"song.mp3\") print( audiofile.tag.artist ) print( audiofile.tag.album ) print( audiofile.tag.album_artist ) print( audiofile.tag.title ) print( audiofile.tag.track_num.count) It is also possible to define default parameter values in the __init__ method to be capable of instantiating a new song without metadata. To learn how to do that, let's go on internet. For instance, the [w3schools]( is an excellent entrance point regarding web technologies and presents, among others, the notion of function default parameter , with a sandbox... 3.c Some commands You should now have a first skeleton of the application we want to create. However, in fact, the goal is to create several commands. So the best way to do that in a first move, is to create several Python files. A first Python file will implement our Song class with all the required functionality as methods of the class. Then we add a Python file for each command we want to implement. In your directory you should have : songpkg.py # With the Song class command1.py command2.py command3.py ... The command script should be as small as possible. All the important code is in songpkg.py , and imported in your command file. For instance, the play.py command will look like import songpkg asong= songpkg.Song() asong.load(\"./song.mp3\") print( f\"{asong.artist()} - {asong.album()} {asong.track()} - {asong.title()}\" ) asound.play() The expected command: play.py : Takes a file name of a song as an argument and print the metadata of that song before playing the song. set.py : Takes a file name of a song and all metadata as command arguments and save the file with those metadata. playlist.py : Takes a playlist as an argument (a text file, with a list of MP3 files to play) and plays it. search.py : Takes an artist name, a search all the local MP3 files matching that artist. rename.py : search all MP3 recursively in a directory, and rename them as artist - album track - title.mp3 . To do that, you will certainly requires os Python modul (again on w3schools ) and more specifically, the os.listdir() returning a list of the names of the entries in a directory.","title":"Object-Oriented Prog."},{"location":"basis-02-poo/#object-oriented-programming","text":"This tutorial revisits OOP concepts, by presenting them in Python. In a second part, an exercise is proposed to create a toolbox for MP3 collection management. All the proposed pieces of code should be tested in a script.py .","title":"Object-Oriented Programming"},{"location":"basis-02-poo/#1-object-oriented-programming-oop-in-python","text":"Playing with class, and the main concepts of OOP in Python .","title":"1. Object-Oriented Programming (OOP) in Python"},{"location":"basis-02-poo/#1a-structuring-element-together","text":"First a class can be reduced to a collection of class attributes and functions. # Definition: class MyObjectType : world= \"world\" def function1() : return \"hello\" def function2() : return MyObjectType.world # Use: hello= MyObjectType.function1() print( hello + ' ' + MyObjectType.function2() ) To notice the indentations that state what is inside a class with a new level of indentation for instructions of the class's function. In this example, MyObjectType is a class with one attribute ( world ) and two functions ( function1() , function2() ).","title":"1.a. Structuring element together"},{"location":"basis-02-poo/#1b-class-instance","text":"The main feature of class is the capacity to instantiate objects ( class instances ). An instance of a class is an object defined as a specific type. It is possible to associate attributes with an instance. In this case, instance-attribute values can be different for different instances of the same class (by opposition to class-attributes). # Definition: class MyObjectType : class_word= \"hello\" # A class attribute # Use: anInstance= MyObjectType() # Instanciate a MyObjectType object anInstance.instance_word= \"world\" # an instance attribute aSecondInstance= MyObjectType() aSecondInstance.instance_word= \"nobody\" assert( type(anInstance) is MyObjectType ) print( anInstance.class_word + ' ' + anInstance.instance_word ) At this point, anInstance.class_word is MyObjectType.class_word , and for no confusion, you should use MyObjectType.class_word to manipulate this attribut. Another good way to manipulate a class attribute: type(anInstance).classAttribut . Typically, nasty manipulation of class-attributes can transform them into instance attributes for specific instances that generate failure, difficult to debug... As in this example : # Definition: class MyObjectType : classAttribut= \"Void\" # Use: anInstance= MyObjectType() MyObjectType.classAttribut= \"Hello\" print( anInstance.classAttribut ) anInstance.classAttribut= \"World\" # I should not do that... print( MyObjectType.classAttribut ) MyObjectType.classAttribut= \"Hmmm\" print( anInstance.classAttribut + \" - \" + MyObjectType.classAttribut )","title":"1.b. Class Instance"},{"location":"basis-02-poo/#1c-methods","text":"The strength of OOP relies on the instances that define a context for the executions of functions associated to the class. A function associated to an instance is named a METHOD . In Python , a method is a class function where the instance is explicit as the first parameter. A convention supposes that this instance is named self . # Definition: class MyObjectType : def method(self) : return 42 # Use: anInstance= MyObjectType() # Instanciate a MyObjectType v1= anInstance.method() v2= MyObjectType.method(anInstance) if v1 == v2 : print( \"Hello World\" ) print( f\"{MyObjectType.method}\\nvs {anInstance.method}\") As in this example, in Python a method can be called directly on an instance ( v1 ) or as a class function ( v2 ). In the first case, the method is bound to an instance : # Definition: class MyObjectType : def method(self) : return 42 anInstance= MyObjectType() print( f\"{MyObjectType.method}\\nvs\\n{anInstance.method} ({anInstance})\") As a result, in Python , a method with \\(3\\) arguments is defined by a function of \\(4\\) arguments. def aMethod(self, argument1, argument2, argument3) : pass","title":"1.c. Methods"},{"location":"basis-02-poo/#2-built-in-python","text":"Python defines numerous tools natively. Many of those tools rely on functions/methods associated with types. There are named built-in functions . Those functions can be redefined (overridden) to attach a specific behavior to developer types (classes).","title":"2. Built-in Python"},{"location":"basis-02-poo/#2a-built-in-class","text":"First of them are the built-in functions defined in Python objects: __init__(self) : Instance initialization, called at instance construction. __del__(self) : Instance destruction, called when a instance is deleted. __str__(self) : Transform an instance in a string # Definition: class MyObjectType : def __init__(self): print('Initialization') def __del__(self): print('Destruction') def __str__(self): return \"> MyObjectType::instance <\" # Use: anInstance= MyObjectType() print( anInstance ) To notice that it is possible to change the number of parameters in __init__ to generate a constructor over parameters. In general, all the instance attributes are created in the __init__ method. But it is not mandatory (in fact, in Python, the number and definition of instance attributes are dynamic). It is also possible to call the parent method when overriding with super . # Definition: class MyObjectType : def __init__(self): print('Initialization') def __del__(self): print('Destruction') def __str__(self): return \"> MyObjectType::instance <\" # Definition: class ObjectSpecific(MyObjectType) : def __init__(self, aNumber): super(MyObjectType, self)._init__(self) self._aNumber= aNumber def __str__(self): return f\"> MyObjectType::instance-{self._aNumber} <\" # Use: anInstance= MyObjectType(42) print( anInstance )","title":"2.a. Built-in Class"},{"location":"basis-02-poo/#2b-good-practices","text":"As we already see, several rules are more good practices than language constraints. The current instance, context for a method execution, is always named self . __init__ method (if defined) is your first method. Initialize your instance attributes into the __init__ method. Attribute names start with _ . Class names start with an Uppercase letter. etc. Most of those conventions are presented in the style guide for Python code","title":"2.b. Good practices."},{"location":"basis-02-poo/#2c-operators","text":"Finally, most of the operator can be redefined based on built-in function. For a complete list with other type built-in functions, see docs.python.org An example with the addition: class Vector : def __init__(self, x, y): self._x= x self._y= y def __add__(self, another): return Vector( self._x+another._x, self._y+another._y ) def __str__(self): return f\"({self._x}, {self._y})\" # Use: a= Vector( 10.7, 8.0 ) b= Vector( -2.1, 34.0 ) print( f\"{a} + {b} = {a+b}\" )","title":"2.c. Operators."},{"location":"basis-02-poo/#3-lets-play","text":"We now have an idea of what OOP is capable of in Python . The exercise here is to put those notions in music.","title":"3. Let's Play"},{"location":"basis-02-poo/#3a-read-a-mp3-sound","text":"As a first exercie we want a class representing a song. First, an exploration on internet showed us the librairie: playsound3 allowing us for play mp3 music. This example loads a music song and play it : import time from playsound3 import playsound # You can play sounds in the background sound = playsound(\"./song.mp3\", block=False) # and check if they are still playing if sound.is_alive() : print(\"Sound is playing!\") time.sleep( 5.0 ) # and stop them whenever you like. sound.stop() So as a first result, we aim to have a class ( Song for instance) with methods to load a music file and to play it. Something like this: class song : # To implement ... asong= Song() asong.load(\"./song.mp3\") aSound.play()","title":"3.a Read a Mp3 sound"},{"location":"basis-02-poo/#3b-accessor","text":"Our Song class defines a few attributes for an instance: a title, an artist name, an album name, and the number of tracks in the album. First, we want a constructor that defines all of these attributes. Then we ask for an accessor method for each of these attributes. class song : # To implement ... asong= Song(\"Rodriguez\", \"Can't Get Away\", \"Searching for Sugar Man\", 7 ) asong.load(\"./song.mp3\") print( f\"{asong.artist()} - {asong.album()} {asong.track()} - {asong.title()}\" ) asound.play() In fact, we will prefer to get metadata from the file directly when loading it. To do that we can count on eyeD3 Python library ( documentation ). Here's a piece of code to help in this mission: import eyed3 audiofile = eyed3.load(\"song.mp3\") print( audiofile.tag.artist ) print( audiofile.tag.album ) print( audiofile.tag.album_artist ) print( audiofile.tag.title ) print( audiofile.tag.track_num.count) It is also possible to define default parameter values in the __init__ method to be capable of instantiating a new song without metadata. To learn how to do that, let's go on internet. For instance, the [w3schools]( is an excellent entrance point regarding web technologies and presents, among others, the notion of function default parameter , with a sandbox...","title":"3.b Accessor"},{"location":"basis-02-poo/#3c-some-commands","text":"You should now have a first skeleton of the application we want to create. However, in fact, the goal is to create several commands. So the best way to do that in a first move, is to create several Python files. A first Python file will implement our Song class with all the required functionality as methods of the class. Then we add a Python file for each command we want to implement. In your directory you should have : songpkg.py # With the Song class command1.py command2.py command3.py ... The command script should be as small as possible. All the important code is in songpkg.py , and imported in your command file. For instance, the play.py command will look like import songpkg asong= songpkg.Song() asong.load(\"./song.mp3\") print( f\"{asong.artist()} - {asong.album()} {asong.track()} - {asong.title()}\" ) asound.play() The expected command: play.py : Takes a file name of a song as an argument and print the metadata of that song before playing the song. set.py : Takes a file name of a song and all metadata as command arguments and save the file with those metadata. playlist.py : Takes a playlist as an argument (a text file, with a list of MP3 files to play) and plays it. search.py : Takes an artist name, a search all the local MP3 files matching that artist. rename.py : search all MP3 recursively in a directory, and rename them as artist - album track - title.mp3 . To do that, you will certainly requires os Python modul (again on w3schools ) and more specifically, the os.listdir() returning a list of the names of the entries in a directory.","title":"3.c Some commands"},{"location":"basis-03-dev/","text":"Developper tools Python, a Modular tool resources: myOwnPkg.py def myWonderfullFunction( aFirstIntergerPaprameter, aSecondIntergerParameters ) intergerSum= aFirstIntergerPaprameter + aSecondIntergerParameters return intergerSum script: myOwnCommand.py import myOwnPkg ... b= myOwnPkg.myWonderfullFunction( a, 40 ) ... Python, a Modular tool Python packages are easy to install with pip tool. pip install tqdm pytest python import relies on environment path variable: import sys print( sys.path )","title":"Developper tools"},{"location":"basis-03-dev/#developper-tools","text":"","title":"Developper tools"},{"location":"basis-03-dev/#python-a-modular-tool","text":"resources: myOwnPkg.py def myWonderfullFunction( aFirstIntergerPaprameter, aSecondIntergerParameters ) intergerSum= aFirstIntergerPaprameter + aSecondIntergerParameters return intergerSum script: myOwnCommand.py import myOwnPkg ... b= myOwnPkg.myWonderfullFunction( a, 40 ) ...","title":"Python, a Modular tool"},{"location":"basis-03-dev/#python-a-modular-tool_1","text":"Python packages are easy to install with pip tool. pip install tqdm pytest python import relies on environment path variable: import sys print( sys.path )","title":"Python, a Modular tool"},{"location":"dev-01-pack/","text":"Python package and Builtin functions","title":"Packaging"},{"location":"dev-01-pack/#python-package-and-builtin-functions","text":"","title":"Python package and Builtin functions"},{"location":"dev-02-tools/","text":"Develloper's tools Mainly Versionning and Test Driven Devellopement. Versionning Keep traces of code changes. Test-Driven Devellopement Define test-cases before to code... Debugging Out of the scope but you can see : Wath your favorit editor is capable of: code.visualstudio.com . The Python debuger lib: pdb And potentially the main Python profiler .","title":"Develloper tools"},{"location":"dev-02-tools/#devellopers-tools","text":"Mainly Versionning and Test Driven Devellopement.","title":"Develloper's tools"},{"location":"dev-02-tools/#versionning","text":"Keep traces of code changes.","title":"Versionning"},{"location":"dev-02-tools/#test-driven-devellopement","text":"Define test-cases before to code...","title":"Test-Driven Devellopement"},{"location":"dev-02-tools/#debugging","text":"Out of the scope but you can see : Wath your favorit editor is capable of: code.visualstudio.com . The Python debuger lib: pdb And potentially the main Python profiler .","title":"Debugging"},{"location":"dev-03-integ/","text":"Integration Python project. pip. pyproject file and pipy...","title":"Integration"},{"location":"dev-03-integ/#integration","text":"Python project. pip. pyproject file and pipy...","title":"Integration"}]}