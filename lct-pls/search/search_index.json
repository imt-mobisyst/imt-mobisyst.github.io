{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Lecture: Python Libs for Sciences","title":"Lecture intro."},{"location":"#lecture-python-libs-for-sciences","text":"","title":"Lecture: Python Libs for Sciences"},{"location":"basis-01-exo/","text":"System and Python Basis - Exercises 1. Exercise: Search for a User's Groups Create a script returning the names (print) of all groups associated with the user. Always process in an incremental way: Decompose the module to develop Implement it step by step Test the solution at each step Initialize your project: Make a new directory : python-data-science for instance. Edit a new Python file: search-group.py with gedit for instance. Test a hello-world script python3 search-group.py Load ressources Open a file and read-it line by line Apply it to /etc/passwd then /etc/group I do not know how to open a file ? search the web... w3schools Search for a specific word (user name) in a lines Detect for instald user in lines Print only lines with instald inside There is a lot of string methods in Python (for instance, still in W3School ) and one of them seems very interesting: find() . Another one split() allows for decomposing a long string regarding a separator character. Reduce to user's Groups Select only the primary group name in /etc/passwd file for the user bob . Select each group name in /etc/groups , each time bob is present. 2. Exercise: Script as a shell command The goal is to transform search-group.py code into a shell command, executable like anyother. Get user name as a command argument For that, use the sys.argv from the Python package sys . This variable provides the list of the command line arguments. In the Shell We aim to call our program by masking the need for the Python3 interpreter. Like that: search-user bob Version 1 : By using an alias (typically alias search-user='python3 search-user.py' ) Version 2 : By using a shebang , to identify the interpreter inside the Python script, and by setting the script executable chmod +x . Anywhere The script is only accessible from the current directory. Resolve this problem Version 1 : Modify the alias definition with a global path to the script. Version 2 : Add the current directory to the PATH variable ( export PATH=$PATH:~/path/to/ ) Anytime The alais or exports are not available in a new shell. To make them automatically defined, you may add the appropriate lines to your local .bashrc file. This file allows the users to tune their bash shell at start time. Exercise: Increased Command split() is restrictive much for extracting some element from a string ? Take a look at Regular Expression in Python w3school Handle bugs (no user name in arguments, ...) Add options to your command: --help or -h for help, -i for printing group ids, -t to test if the user is in a specific group, ... Make a new directory : python-data-science for instance. Edit a new Python file: search-group.py with gedit for instance. Test a hello-world script python3 search-group.py","title":"First exos"},{"location":"basis-01-exo/#system-and-python-basis-exercises","text":"","title":"System and Python Basis - Exercises"},{"location":"basis-01-exo/#1-exercise-search-for-a-users-groups","text":"Create a script returning the names (print) of all groups associated with the user. Always process in an incremental way: Decompose the module to develop Implement it step by step Test the solution at each step","title":"1. Exercise: Search for a User's Groups"},{"location":"basis-01-exo/#initialize-your-project","text":"Make a new directory : python-data-science for instance. Edit a new Python file: search-group.py with gedit for instance. Test a hello-world script python3 search-group.py","title":"Initialize your project:"},{"location":"basis-01-exo/#load-ressources","text":"Open a file and read-it line by line Apply it to /etc/passwd then /etc/group I do not know how to open a file ? search the web... w3schools","title":"Load ressources"},{"location":"basis-01-exo/#search-for-a-specific-word-user-name-in-a-lines","text":"Detect for instald user in lines Print only lines with instald inside There is a lot of string methods in Python (for instance, still in W3School ) and one of them seems very interesting: find() . Another one split() allows for decomposing a long string regarding a separator character.","title":"Search for a specific word (user name) in a lines"},{"location":"basis-01-exo/#reduce-to-users-groups","text":"Select only the primary group name in /etc/passwd file for the user bob . Select each group name in /etc/groups , each time bob is present.","title":"Reduce to user's Groups"},{"location":"basis-01-exo/#2-exercise-script-as-a-shell-command","text":"The goal is to transform search-group.py code into a shell command, executable like anyother.","title":"2. Exercise: Script as a shell command"},{"location":"basis-01-exo/#get-user-name-as-a-command-argument","text":"For that, use the sys.argv from the Python package sys . This variable provides the list of the command line arguments.","title":"Get user name as a command argument"},{"location":"basis-01-exo/#in-the-shell","text":"We aim to call our program by masking the need for the Python3 interpreter. Like that: search-user bob Version 1 : By using an alias (typically alias search-user='python3 search-user.py' ) Version 2 : By using a shebang , to identify the interpreter inside the Python script, and by setting the script executable chmod +x .","title":"In the Shell"},{"location":"basis-01-exo/#anywhere","text":"The script is only accessible from the current directory. Resolve this problem Version 1 : Modify the alias definition with a global path to the script. Version 2 : Add the current directory to the PATH variable ( export PATH=$PATH:~/path/to/ )","title":"Anywhere"},{"location":"basis-01-exo/#anytime","text":"The alais or exports are not available in a new shell. To make them automatically defined, you may add the appropriate lines to your local .bashrc file. This file allows the users to tune their bash shell at start time.","title":"Anytime"},{"location":"basis-01-exo/#exercise-increased-command","text":"split() is restrictive much for extracting some element from a string ? Take a look at Regular Expression in Python w3school Handle bugs (no user name in arguments, ...) Add options to your command: --help or -h for help, -i for printing group ids, -t to test if the user is in a specific group, ... Make a new directory : python-data-science for instance. Edit a new Python file: search-group.py with gedit for instance. Test a hello-world script python3 search-group.py","title":"Exercise: Increased Command"},{"location":"basis-01-system/","text":"The basics: The computer and the program 1. At the beginning was the Shell : A computer program that exposes an operating system's services to a human user or other programs. ( Wikipedia - Sep. 2023 ) (also named a terminal ) Some Vocabulary: Prompt : A command prompt (or just prompt) state in the command-line interface indicating readiness to accept commands. Command : an instruction received via an external interface that directs the behavior of a computer program. In other terms, a call to a program with potentially specific attributes. 2. First BASH Commands. Bash is the most popular Unix/Linux shell, available by default on most Linux distributions. It is also natively supported on Apple, and versions of Bash can be installed with tools like MinGW on Windows However, most of the commands presented here exist in other Shell or have some equivalents. 2.a. The File System First of all, some commands allow a user to navigate in file systems et interact with it. ls - list directory elements cd - change directory cat - read all a text file more - read a text file step by step touch - touch a resource (create it) nano - edit a text file rm - remove a file (permanently) mkdir - create (make) a directory rmdir - remove a directory mv - move a resource cp - copy-paste a file clear - clear your promt Most of this commands manipulate paths - a description of where to find a resource on the computer -. / - the root directory in Linux system - example: du /bin/bash (du - estimate file space usage) . - the current directory - example: mkdir ./workspace .. - the parent directory - example: cd ../../media ~ - the user directory (home) - example: cd ~/Documents CApitAl Letters maTer - example: cd ~/Documents \\(\\neq\\) cd ~/documents 2.b. Mastering Commands Most of the commands accept arguments and options. With a simplistic vision, the argument gives a target to the command execution, while options permit the user to change the context execution of the command. Classical syntax: command --option -o argument - example: ls -a ~ Some commands permit manipulating the command collection. man - command and library manual - example: man cp apropos - search in the manuals - example: apropos search whereis - find the location of a resource - example: whereis python3 alias - create our own command - example: alias listall=\"ls -a\" 2.c. Some triks : tabulation : auto-complete the command line or list the possibilities. !xx : run again the last command starting with xx . ctrl-r : search for a command in command history. Q : quit a running program (in most programs). ctr-c : terminate a running program. ~/.bashrc : file: user configuration routine. 3. Users session On Linux, users are clearly identified everywhere. All resources have owners, and users can be limited in their capacities on the system. Users can be artificially set, they are not necessarily real human beings. 3.a. session A session is an active connection to a system or program. who - list the open session in a computer su : start a new session as a specific user - example: su bob ssh - open a session in a distant computer following the ssh protocol A user session is associated with an environment. I.e. a computer system or set of systems in which a computer program or software component is deployed and executed ( Wikipedia Sept. 2023 ). env - list the environment variable. $ - access a variable - example: echo $PATH $PATH - list of all directories where bash search the commands. $SHELL - the current shell interpreter. $USER - the user name. export - create a new variable - example: export MYBIN=~/bin ~/.bashrc (file): user configuration commands. 3.b. User, Group and Rules Users are structured with groups . Users as groups have a name and a number A user is defined with a primary group , its main group, but a group can include several users. The files /etc/passwd and /etc/group record that information, among others. List them with cat for example ( cat /etc/passwd and cat /etc/group ). Specific access is associated to each resource on the computer with r : read \\(\\quad\\) w : write \\(\\quad\\) x : executed/open. The triple authorization can be different for the user owner, the group owner, or all the others. List command with the -l option gives ownership and authorization information, among others. For example, with ls -l /etc Manipulate the owner and authorizations: chmod : change authorizations - Examples: chmod +x aFile - add x authorization on aFile chmod 752 aFile - set authorization on aFile on a binary style chown : change the owner sudo : excute a command as a root user (administrator) if granted - example sudo gedit /etc/passwd . 4. The Processes Finally, the Operating System (OS) is mainly a process manager... An OS offers an environment to create and execute programs. Typically, the language C is first developed in parallel to Unix to provide a powerful language to the OS, and to use it for the OS core processes. Today, systems have evolved significantly and allow complex architecture with several processes running in parallel and potentially in virtual machines. Similarly to ls , ps list the local processes (ie. the children processes of the bash shell). For instance: gedit aFile.txt & ps Here, & permits to get the prompt back after starting gedit . As for other commands, ps accepts options, for instance, adding -e lists all the processes on the machine. For managing processes, OS attaches some elements to each one: the PID (Process IDentifier), a parent process, an owner, a name, ... Other command : top - interactive process monitoring ( Q to quit ) (quite similar to ps , but interactive and constantly updated) kill - sent a signal to a process - Examples: kill 19482 - send TERM signal to process 19482 ; kill -s KILL 19482 - send KILL signal to process 19482 Codes, Programs and Scripts Codes : Sequence of written instruction text format according to a given programming language. Programs : Executable binary on a OS Specific to the OS (and potentially to the hardware) Generally compiled codes (example with C language compiled with gcc ). Scripts : Interpretable pieces of code by a program. Typically, Python is a scripting language. file: hello.py 5. Python Programming Languages Python is a high level programming language. Its allows for abstracted data structures, includes core tools like dynamic type , garbage colector , Object-Oriented Programming (OOP) and a lot more with a large collection of libraries. The language is interpreted, and python3 designs the programming language but also the interpreter process ( cpython ), allowing reading and executing Python instructions. Code source on github.com - 63.5% Python / 34.6% C Minimale python script: print('hello world') Then in a shell: python3 hello.py Python in short: Rich language capabilities (it is possible to do complex things) Concise language (complex things require few codes) Very rich community libraries (most of the complex things are already implemented) Interpretable (the code is mostly OS independent) Use a virtual machine (including Garbage Collector) Not natively efficient (but compatible with C and C++ libs) 4.a Sequential Instructions Python is structured with sequential instructions: # Some comments... a= 1 # - Asignment of a new integer variable b= a + 48.4 # - Asignment of a new floating point variable # as the result of the instruction: a + 48.4 aString= \"Hello\" # - Assignment of a new string variable (list of characters) print( aString ) # - Call to the function print with aString as one parameter result= aString.find('e') # - Call to the method search on the aString instance # with a parameter 'e' It allows for function definition. def myWonderfullFunction( aFirstIntergerPaprameter, aSecondIntergerParameters ): intergerSum= aFirstIntergerPaprameter + aSecondIntergerParameters return intergerSum a= 2 b= myWonderfullFunction( a, 40 ) print( \"Result: \" + str(b) ) To notice: Block separation is delimited with space or tabulation indentation. Functions need to be defined prior to be used. 4.b loop control Loops allow for repeating an instruction sequence until a specific state is reached ( while ) or by visiting a collection of objects ( for ). The while instruction ( WHILE condition DO something ) is the simplest available loop control: b= 0 while b <= 40 : b+= 2 print( \"Result: \" + str(b) ) The for instruction allows for visiting each element of an iterable collection, for instance, a list. aList= [2, 10, 18, 4, 8] b= 0 for value in aList : b+= value print( \"Result: \" + str(b) ) 4.c Going further... It is not the purpose here, to provide an entire course on Python . There are huge resources on the internet, both more complete and well organized, starting with the official Python documentation https://docs.python.org/3/ . We highly recommend searching the web to increase your knowledge. In this jungle, the w3schools certainly offers the best learning experience. You can start, for instance, with Python lists and Python dictionaries , the two most used data structures in Python. Finally, complementary modules / packages can be associated to the code with the import instruction. Typically sys package provides some interfaces with the system. import sys print( \"System platform: \"+ str(sys.platform) )","title":"OS & language"},{"location":"basis-01-system/#the-basics-the-computer-and-the-program","text":"","title":"The basics: The computer and the program"},{"location":"basis-01-system/#1-at-the-beginning-was-the-shell","text":"A computer program that exposes an operating system's services to a human user or other programs. ( Wikipedia - Sep. 2023 ) (also named a terminal )","title":"1. At the beginning was the Shell :"},{"location":"basis-01-system/#some-vocabulary","text":"Prompt : A command prompt (or just prompt) state in the command-line interface indicating readiness to accept commands. Command : an instruction received via an external interface that directs the behavior of a computer program. In other terms, a call to a program with potentially specific attributes.","title":"Some Vocabulary:"},{"location":"basis-01-system/#2-first-bash-commands","text":"Bash is the most popular Unix/Linux shell, available by default on most Linux distributions. It is also natively supported on Apple, and versions of Bash can be installed with tools like MinGW on Windows However, most of the commands presented here exist in other Shell or have some equivalents.","title":"2. First BASH Commands."},{"location":"basis-01-system/#2a-the-file-system","text":"First of all, some commands allow a user to navigate in file systems et interact with it. ls - list directory elements cd - change directory cat - read all a text file more - read a text file step by step touch - touch a resource (create it) nano - edit a text file rm - remove a file (permanently) mkdir - create (make) a directory rmdir - remove a directory mv - move a resource cp - copy-paste a file clear - clear your promt Most of this commands manipulate paths - a description of where to find a resource on the computer -. / - the root directory in Linux system - example: du /bin/bash (du - estimate file space usage) . - the current directory - example: mkdir ./workspace .. - the parent directory - example: cd ../../media ~ - the user directory (home) - example: cd ~/Documents CApitAl Letters maTer - example: cd ~/Documents \\(\\neq\\) cd ~/documents","title":"2.a. The File System"},{"location":"basis-01-system/#2b-mastering-commands","text":"Most of the commands accept arguments and options. With a simplistic vision, the argument gives a target to the command execution, while options permit the user to change the context execution of the command. Classical syntax: command --option -o argument - example: ls -a ~ Some commands permit manipulating the command collection. man - command and library manual - example: man cp apropos - search in the manuals - example: apropos search whereis - find the location of a resource - example: whereis python3 alias - create our own command - example: alias listall=\"ls -a\"","title":"2.b. Mastering Commands"},{"location":"basis-01-system/#2c-some-triks","text":"tabulation : auto-complete the command line or list the possibilities. !xx : run again the last command starting with xx . ctrl-r : search for a command in command history. Q : quit a running program (in most programs). ctr-c : terminate a running program. ~/.bashrc : file: user configuration routine.","title":"2.c. Some triks :"},{"location":"basis-01-system/#3-users-session","text":"On Linux, users are clearly identified everywhere. All resources have owners, and users can be limited in their capacities on the system. Users can be artificially set, they are not necessarily real human beings.","title":"3. Users session"},{"location":"basis-01-system/#3a-session","text":"A session is an active connection to a system or program. who - list the open session in a computer su : start a new session as a specific user - example: su bob ssh - open a session in a distant computer following the ssh protocol A user session is associated with an environment. I.e. a computer system or set of systems in which a computer program or software component is deployed and executed ( Wikipedia Sept. 2023 ). env - list the environment variable. $ - access a variable - example: echo $PATH $PATH - list of all directories where bash search the commands. $SHELL - the current shell interpreter. $USER - the user name. export - create a new variable - example: export MYBIN=~/bin ~/.bashrc (file): user configuration commands.","title":"3.a. session"},{"location":"basis-01-system/#3b-user-group-and-rules","text":"Users are structured with groups . Users as groups have a name and a number A user is defined with a primary group , its main group, but a group can include several users. The files /etc/passwd and /etc/group record that information, among others. List them with cat for example ( cat /etc/passwd and cat /etc/group ). Specific access is associated to each resource on the computer with r : read \\(\\quad\\) w : write \\(\\quad\\) x : executed/open. The triple authorization can be different for the user owner, the group owner, or all the others. List command with the -l option gives ownership and authorization information, among others. For example, with ls -l /etc Manipulate the owner and authorizations: chmod : change authorizations - Examples: chmod +x aFile - add x authorization on aFile chmod 752 aFile - set authorization on aFile on a binary style chown : change the owner sudo : excute a command as a root user (administrator) if granted - example sudo gedit /etc/passwd .","title":"3.b. User, Group and Rules"},{"location":"basis-01-system/#4-the-processes","text":"Finally, the Operating System (OS) is mainly a process manager... An OS offers an environment to create and execute programs. Typically, the language C is first developed in parallel to Unix to provide a powerful language to the OS, and to use it for the OS core processes. Today, systems have evolved significantly and allow complex architecture with several processes running in parallel and potentially in virtual machines. Similarly to ls , ps list the local processes (ie. the children processes of the bash shell). For instance: gedit aFile.txt & ps Here, & permits to get the prompt back after starting gedit . As for other commands, ps accepts options, for instance, adding -e lists all the processes on the machine. For managing processes, OS attaches some elements to each one: the PID (Process IDentifier), a parent process, an owner, a name, ... Other command : top - interactive process monitoring ( Q to quit ) (quite similar to ps , but interactive and constantly updated) kill - sent a signal to a process - Examples: kill 19482 - send TERM signal to process 19482 ; kill -s KILL 19482 - send KILL signal to process 19482","title":"4. The Processes"},{"location":"basis-01-system/#codes-programs-and-scripts","text":"Codes : Sequence of written instruction text format according to a given programming language. Programs : Executable binary on a OS Specific to the OS (and potentially to the hardware) Generally compiled codes (example with C language compiled with gcc ). Scripts : Interpretable pieces of code by a program. Typically, Python is a scripting language. file: hello.py","title":"Codes, Programs and Scripts"},{"location":"basis-01-system/#5-python-programming-languages","text":"Python is a high level programming language. Its allows for abstracted data structures, includes core tools like dynamic type , garbage colector , Object-Oriented Programming (OOP) and a lot more with a large collection of libraries. The language is interpreted, and python3 designs the programming language but also the interpreter process ( cpython ), allowing reading and executing Python instructions. Code source on github.com - 63.5% Python / 34.6% C Minimale python script: print('hello world') Then in a shell: python3 hello.py Python in short: Rich language capabilities (it is possible to do complex things) Concise language (complex things require few codes) Very rich community libraries (most of the complex things are already implemented) Interpretable (the code is mostly OS independent) Use a virtual machine (including Garbage Collector) Not natively efficient (but compatible with C and C++ libs)","title":"5. Python Programming Languages"},{"location":"basis-01-system/#4a-sequential-instructions","text":"Python is structured with sequential instructions: # Some comments... a= 1 # - Asignment of a new integer variable b= a + 48.4 # - Asignment of a new floating point variable # as the result of the instruction: a + 48.4 aString= \"Hello\" # - Assignment of a new string variable (list of characters) print( aString ) # - Call to the function print with aString as one parameter result= aString.find('e') # - Call to the method search on the aString instance # with a parameter 'e' It allows for function definition. def myWonderfullFunction( aFirstIntergerPaprameter, aSecondIntergerParameters ): intergerSum= aFirstIntergerPaprameter + aSecondIntergerParameters return intergerSum a= 2 b= myWonderfullFunction( a, 40 ) print( \"Result: \" + str(b) ) To notice: Block separation is delimited with space or tabulation indentation. Functions need to be defined prior to be used.","title":"4.a Sequential Instructions"},{"location":"basis-01-system/#4b-loop-control","text":"Loops allow for repeating an instruction sequence until a specific state is reached ( while ) or by visiting a collection of objects ( for ). The while instruction ( WHILE condition DO something ) is the simplest available loop control: b= 0 while b <= 40 : b+= 2 print( \"Result: \" + str(b) ) The for instruction allows for visiting each element of an iterable collection, for instance, a list. aList= [2, 10, 18, 4, 8] b= 0 for value in aList : b+= value print( \"Result: \" + str(b) )","title":"4.b loop control"},{"location":"basis-01-system/#4c-going-further","text":"It is not the purpose here, to provide an entire course on Python . There are huge resources on the internet, both more complete and well organized, starting with the official Python documentation https://docs.python.org/3/ . We highly recommend searching the web to increase your knowledge. In this jungle, the w3schools certainly offers the best learning experience. You can start, for instance, with Python lists and Python dictionaries , the two most used data structures in Python. Finally, complementary modules / packages can be associated to the code with the import instruction. Typically sys package provides some interfaces with the system. import sys print( \"System platform: \"+ str(sys.platform) )","title":"4.c Going further..."},{"location":"basis-02-poo/","text":"Object-Oriented Programming This tutorial revisits OOP concepts, by presenting them in Python. In a second part, an exercise is proposed to create a toolbox for MP3 collection management. All the proposed pieces of code should be tested in a script.py . 1. Object-Oriented Programming (OOP) in Python Playing with class, and the main concepts of OOP in Python . 1.a. Structuring element together First a class can be reduced to a collection of class attributes and functions. # Definition: class MyObjectType : world= \"world\" def function1() : return \"hello\" def function2() : return MyObjectType.world # Use: hello= MyObjectType.function1() print( hello + ' ' + MyObjectType.function2() ) To notice the indentations that state what is inside a class with a new level of indentation for instructions of the class's function. In this example, MyObjectType is a class with one attribute ( world ) and two functions ( function1() , function2() ). 1.b. Class Instance The main feature of class is the capacity to instantiate objects ( class instances ). An instance of a class is an object defined as a specific type. It is possible to associate attributes with an instance. In this case, instance-attribute values can be different for different instances of the same class (by opposition to class-attributes). # Definition: class MyObjectType : class_word= \"hello\" # A class attribute # Use: anInstance= MyObjectType() # Instanciate a MyObjectType object anInstance.instance_word= \"world\" # an instance attribute aSecondInstance= MyObjectType() aSecondInstance.instance_word= \"nobody\" assert( type(anInstance) is MyObjectType ) print( anInstance.class_word + ' ' + anInstance.instance_word ) At this point, anInstance.class_word is MyObjectType.class_word , and for no confusion, you should use MyObjectType.class_word to manipulate this attribut. Another good way to manipulate a class attribute: type(anInstance).classAttribut . Typically, nasty manipulation of class-attributes can transform them into instance attributes for specific instances that generate failure, difficult to debug... As in this example : # Definition: class MyObjectType : classAttribut= \"Void\" # Use: anInstance= MyObjectType() MyObjectType.classAttribut= \"Hello\" print( anInstance.classAttribut ) anInstance.classAttribut= \"World\" # I should not do that... print( MyObjectType.classAttribut ) MyObjectType.classAttribut= \"Hmmm\" print( anInstance.classAttribut + \" - \" + MyObjectType.classAttribut ) 1.c. Methods The strength of OOP relies on the instances that define a context for the executions of functions associated to the class. A function associated to an instance is named a METHOD . In Python , a method is a class function where the instance is explicit as the first parameter. A convention supposes that this instance is named self . # Definition: class MyObjectType : def method(self) : return 42 # Use: anInstance= MyObjectType() # Instanciate a MyObjectType v1= anInstance.method() v2= MyObjectType.method(anInstance) if v1 == v2 : print( \"Hello World\" ) print( f\"{MyObjectType.method}\\nvs {anInstance.method}\") As in this example, in Python a method can be called directly on an instance ( v1 ) or as a class function ( v2 ). In the first case, the method is bound to an instance : # Definition: class MyObjectType : def method(self) : return 42 anInstance= MyObjectType() print( f\"{MyObjectType.method}\\nvs\\n{anInstance.method} ({anInstance})\") As a result, in Python , a method with \\(3\\) arguments is defined by a function of \\(4\\) arguments. def aMethod(self, argument1, argument2, argument3) : pass 2. Built-in Python Python defines numerous tools natively. Many of those tools rely on functions/methods associated with types. There are named built-in functions . Those functions can be redefined (overridden) to attach a specific behavior to developer types (classes). 2.a. Built-in Class First of them are the built-in functions defined in Python objects: __init__(self) : Instance initialization, called at instance construction. __del__(self) : Instance destruction, called when a instance is deleted. __str__(self) : Transform an instance in a string # Definition: class MyObjectType : def __init__(self): print('Initialization') def __del__(self): print('Destruction') def __str__(self): return \"> MyObjectType::instance <\" # Use: anInstance= MyObjectType() print( anInstance ) To notice that it is possible to change the number of parameters in __init__ to generate a constructor over parameters. In general, all the instance attributes are created in the __init__ method. But it is not mandatory (in fact, in Python, the number and definition of instance attributes are dynamic). It is also possible to call the parent method when overriding with super . # Definition: class MyObjectType : def __init__(self): print('Initialization') def __del__(self): print('Destruction') def __str__(self): return \"> MyObjectType::instance <\" # Definition: class ObjectSpecific(MyObjectType) : def __init__(self, aNumber): super(MyObjectType, self).__init__() self._aNumber= aNumber def __str__(self): return f\"> MyObjectType::instance-{self._aNumber} <\" # Use: anInstance= ObjectSpecific(42) print( anInstance ) 2.b. Good practices. As we already see, several rules are more good practices than language constraints. The current instance, context for a method execution, is always named self . __init__ method (if defined) is your first method. Initialize your instance attributes into the __init__ method. Attribute names start with _ . Class names start with an Uppercase letter. etc. Most of those conventions are presented in the style guide for Python code 2.c. Operators. Finally, most of the operator can be redefined based on built-in function. For a complete list with other type built-in functions, see docs.python.org An example with the addition: class Vector : def __init__(self, x, y): self._x= x self._y= y def __add__(self, another): return Vector( self._x+another._x, self._y+another._y ) def __str__(self): return f\"({self._x}, {self._y})\" # Use: a= Vector( 10.7, 8.0 ) b= Vector( -2.1, 34.0 ) print( f\"{a} + {b} = {a+b}\" ) 3. Let's Play We now have an idea of what OOP is capable of in Python . The exercise here is to put those notions in music. 3.a Read a Mp3 sound As a first exercie we want a class representing a song. First, an exploration on internet showed us the librairie: playsound3 allowing us for play mp3 music. This example loads a music song and play it : import time from playsound3 import playsound # You can play sounds in the background sound = playsound(\"./song.mp3\", block=False) # and check if they are still playing if sound.is_alive() : print(\"Sound is playing!\") time.sleep( 5.0 ) # and stop them whenever you like. sound.stop() So as a first result, we aim to have a class ( Song for instance) with methods to load a music file and to play it. Something like this: class song : # To implement ... asong= Song() asong.load(\"./song.mp3\") aSound.play() The song file : here 3.b Accessor Our Song class defines a few attributes for an instance: a title, an artist name, an album name, and the number of tracks in the album. First, we want a constructor that defines all of these attributes. Then we ask for an accessor method for each of these attributes. class song : # To implement ... asong= Song(\"Rodriguez\", \"Can't Get Away\", \"Searching for Sugar Man\", 7 ) asong.load(\"./song.mp3\") print( f\"{asong.artist()} - {asong.album()} {asong.track()} - {asong.title()}\" ) asound.play() In fact, we will prefer to get metadata from the file directly when loading it. To do that we can count on eyeD3 Python library ( documentation ). Here's a piece of code to help in this mission: import eyed3 audiofile = eyed3.load(\"song.mp3\") print( audiofile.tag.artist ) print( audiofile.tag.album ) print( audiofile.tag.album_artist ) print( audiofile.tag.title ) print( audiofile.tag.track_num.count) It is also possible to define default parameter values in the __init__ method to be capable of instantiating a new song without metadata. To learn how to do that, let's go on internet. For instance, the [w3schools]( is an excellent entrance point regarding web technologies and presents, among others, the notion of function default parameter , with a sandbox... 3.c Some commands You should now have a first skeleton of the application we want to create. However, in fact, the goal is to create several commands. So the best way to do that in a first move, is to create several Python files. A first Python file will implement our Song class with all the required functionality as methods of the class. Then we add a Python file for each command we want to implement. In your directory you should have : songpkg.py # With the Song class command1.py command2.py command3.py ... The command script should be as small as possible. All the important code is in songpkg.py , and imported in your command file. For instance, the play.py command will look like import songpkg asong= songpkg.Song() asong.load(\"./song.mp3\") print( f\"{asong.artist()} - {asong.album()} {asong.track()} - {asong.title()}\" ) asound.play() The expected command: play.py : Takes a file name of a song as an argument and print the metadata of that song before playing the song. set.py : Takes a file name of a song and all metadata as command arguments and save the file with those metadata. playlist.py : Takes a playlist as an argument (a text file, with a list of MP3 files to play) and plays it. search.py : Takes an artist name, a search all the local MP3 files matching that artist. rename.py : search all MP3 recursively in a directory, and rename them as artist - album track - title.mp3 . To do that, you will certainly requires os Python modul (again on w3schools ) and more specifically, the os.listdir() returning a list of the names of the entries in a directory.","title":"Object-Oriented Prog."},{"location":"basis-02-poo/#object-oriented-programming","text":"This tutorial revisits OOP concepts, by presenting them in Python. In a second part, an exercise is proposed to create a toolbox for MP3 collection management. All the proposed pieces of code should be tested in a script.py .","title":"Object-Oriented Programming"},{"location":"basis-02-poo/#1-object-oriented-programming-oop-in-python","text":"Playing with class, and the main concepts of OOP in Python .","title":"1. Object-Oriented Programming (OOP) in Python"},{"location":"basis-02-poo/#1a-structuring-element-together","text":"First a class can be reduced to a collection of class attributes and functions. # Definition: class MyObjectType : world= \"world\" def function1() : return \"hello\" def function2() : return MyObjectType.world # Use: hello= MyObjectType.function1() print( hello + ' ' + MyObjectType.function2() ) To notice the indentations that state what is inside a class with a new level of indentation for instructions of the class's function. In this example, MyObjectType is a class with one attribute ( world ) and two functions ( function1() , function2() ).","title":"1.a. Structuring element together"},{"location":"basis-02-poo/#1b-class-instance","text":"The main feature of class is the capacity to instantiate objects ( class instances ). An instance of a class is an object defined as a specific type. It is possible to associate attributes with an instance. In this case, instance-attribute values can be different for different instances of the same class (by opposition to class-attributes). # Definition: class MyObjectType : class_word= \"hello\" # A class attribute # Use: anInstance= MyObjectType() # Instanciate a MyObjectType object anInstance.instance_word= \"world\" # an instance attribute aSecondInstance= MyObjectType() aSecondInstance.instance_word= \"nobody\" assert( type(anInstance) is MyObjectType ) print( anInstance.class_word + ' ' + anInstance.instance_word ) At this point, anInstance.class_word is MyObjectType.class_word , and for no confusion, you should use MyObjectType.class_word to manipulate this attribut. Another good way to manipulate a class attribute: type(anInstance).classAttribut . Typically, nasty manipulation of class-attributes can transform them into instance attributes for specific instances that generate failure, difficult to debug... As in this example : # Definition: class MyObjectType : classAttribut= \"Void\" # Use: anInstance= MyObjectType() MyObjectType.classAttribut= \"Hello\" print( anInstance.classAttribut ) anInstance.classAttribut= \"World\" # I should not do that... print( MyObjectType.classAttribut ) MyObjectType.classAttribut= \"Hmmm\" print( anInstance.classAttribut + \" - \" + MyObjectType.classAttribut )","title":"1.b. Class Instance"},{"location":"basis-02-poo/#1c-methods","text":"The strength of OOP relies on the instances that define a context for the executions of functions associated to the class. A function associated to an instance is named a METHOD . In Python , a method is a class function where the instance is explicit as the first parameter. A convention supposes that this instance is named self . # Definition: class MyObjectType : def method(self) : return 42 # Use: anInstance= MyObjectType() # Instanciate a MyObjectType v1= anInstance.method() v2= MyObjectType.method(anInstance) if v1 == v2 : print( \"Hello World\" ) print( f\"{MyObjectType.method}\\nvs {anInstance.method}\") As in this example, in Python a method can be called directly on an instance ( v1 ) or as a class function ( v2 ). In the first case, the method is bound to an instance : # Definition: class MyObjectType : def method(self) : return 42 anInstance= MyObjectType() print( f\"{MyObjectType.method}\\nvs\\n{anInstance.method} ({anInstance})\") As a result, in Python , a method with \\(3\\) arguments is defined by a function of \\(4\\) arguments. def aMethod(self, argument1, argument2, argument3) : pass","title":"1.c. Methods"},{"location":"basis-02-poo/#2-built-in-python","text":"Python defines numerous tools natively. Many of those tools rely on functions/methods associated with types. There are named built-in functions . Those functions can be redefined (overridden) to attach a specific behavior to developer types (classes).","title":"2. Built-in Python"},{"location":"basis-02-poo/#2a-built-in-class","text":"First of them are the built-in functions defined in Python objects: __init__(self) : Instance initialization, called at instance construction. __del__(self) : Instance destruction, called when a instance is deleted. __str__(self) : Transform an instance in a string # Definition: class MyObjectType : def __init__(self): print('Initialization') def __del__(self): print('Destruction') def __str__(self): return \"> MyObjectType::instance <\" # Use: anInstance= MyObjectType() print( anInstance ) To notice that it is possible to change the number of parameters in __init__ to generate a constructor over parameters. In general, all the instance attributes are created in the __init__ method. But it is not mandatory (in fact, in Python, the number and definition of instance attributes are dynamic). It is also possible to call the parent method when overriding with super . # Definition: class MyObjectType : def __init__(self): print('Initialization') def __del__(self): print('Destruction') def __str__(self): return \"> MyObjectType::instance <\" # Definition: class ObjectSpecific(MyObjectType) : def __init__(self, aNumber): super(MyObjectType, self).__init__() self._aNumber= aNumber def __str__(self): return f\"> MyObjectType::instance-{self._aNumber} <\" # Use: anInstance= ObjectSpecific(42) print( anInstance )","title":"2.a. Built-in Class"},{"location":"basis-02-poo/#2b-good-practices","text":"As we already see, several rules are more good practices than language constraints. The current instance, context for a method execution, is always named self . __init__ method (if defined) is your first method. Initialize your instance attributes into the __init__ method. Attribute names start with _ . Class names start with an Uppercase letter. etc. Most of those conventions are presented in the style guide for Python code","title":"2.b. Good practices."},{"location":"basis-02-poo/#2c-operators","text":"Finally, most of the operator can be redefined based on built-in function. For a complete list with other type built-in functions, see docs.python.org An example with the addition: class Vector : def __init__(self, x, y): self._x= x self._y= y def __add__(self, another): return Vector( self._x+another._x, self._y+another._y ) def __str__(self): return f\"({self._x}, {self._y})\" # Use: a= Vector( 10.7, 8.0 ) b= Vector( -2.1, 34.0 ) print( f\"{a} + {b} = {a+b}\" )","title":"2.c. Operators."},{"location":"basis-02-poo/#3-lets-play","text":"We now have an idea of what OOP is capable of in Python . The exercise here is to put those notions in music.","title":"3. Let's Play"},{"location":"basis-02-poo/#3a-read-a-mp3-sound","text":"As a first exercie we want a class representing a song. First, an exploration on internet showed us the librairie: playsound3 allowing us for play mp3 music. This example loads a music song and play it : import time from playsound3 import playsound # You can play sounds in the background sound = playsound(\"./song.mp3\", block=False) # and check if they are still playing if sound.is_alive() : print(\"Sound is playing!\") time.sleep( 5.0 ) # and stop them whenever you like. sound.stop() So as a first result, we aim to have a class ( Song for instance) with methods to load a music file and to play it. Something like this: class song : # To implement ... asong= Song() asong.load(\"./song.mp3\") aSound.play() The song file : here","title":"3.a Read a Mp3 sound"},{"location":"basis-02-poo/#3b-accessor","text":"Our Song class defines a few attributes for an instance: a title, an artist name, an album name, and the number of tracks in the album. First, we want a constructor that defines all of these attributes. Then we ask for an accessor method for each of these attributes. class song : # To implement ... asong= Song(\"Rodriguez\", \"Can't Get Away\", \"Searching for Sugar Man\", 7 ) asong.load(\"./song.mp3\") print( f\"{asong.artist()} - {asong.album()} {asong.track()} - {asong.title()}\" ) asound.play() In fact, we will prefer to get metadata from the file directly when loading it. To do that we can count on eyeD3 Python library ( documentation ). Here's a piece of code to help in this mission: import eyed3 audiofile = eyed3.load(\"song.mp3\") print( audiofile.tag.artist ) print( audiofile.tag.album ) print( audiofile.tag.album_artist ) print( audiofile.tag.title ) print( audiofile.tag.track_num.count) It is also possible to define default parameter values in the __init__ method to be capable of instantiating a new song without metadata. To learn how to do that, let's go on internet. For instance, the [w3schools]( is an excellent entrance point regarding web technologies and presents, among others, the notion of function default parameter , with a sandbox...","title":"3.b Accessor"},{"location":"basis-02-poo/#3c-some-commands","text":"You should now have a first skeleton of the application we want to create. However, in fact, the goal is to create several commands. So the best way to do that in a first move, is to create several Python files. A first Python file will implement our Song class with all the required functionality as methods of the class. Then we add a Python file for each command we want to implement. In your directory you should have : songpkg.py # With the Song class command1.py command2.py command3.py ... The command script should be as small as possible. All the important code is in songpkg.py , and imported in your command file. For instance, the play.py command will look like import songpkg asong= songpkg.Song() asong.load(\"./song.mp3\") print( f\"{asong.artist()} - {asong.album()} {asong.track()} - {asong.title()}\" ) asound.play() The expected command: play.py : Takes a file name of a song as an argument and print the metadata of that song before playing the song. set.py : Takes a file name of a song and all metadata as command arguments and save the file with those metadata. playlist.py : Takes a playlist as an argument (a text file, with a list of MP3 files to play) and plays it. search.py : Takes an artist name, a search all the local MP3 files matching that artist. rename.py : search all MP3 recursively in a directory, and rename them as artist - album track - title.mp3 . To do that, you will certainly requires os Python modul (again on w3schools ) and more specifically, the os.listdir() returning a list of the names of the entries in a directory.","title":"3.c Some commands"},{"location":"basis-03-dev/","text":"Developper tools Python, a Modular tool resources: myOwnPkg.py def myWonderfullFunction( aFirstIntergerPaprameter, aSecondIntergerParameters ) intergerSum= aFirstIntergerPaprameter + aSecondIntergerParameters return intergerSum script: myOwnCommand.py import myOwnPkg ... b= myOwnPkg.myWonderfullFunction( a, 40 ) ... Python, a Modular tool Python packages are easy to install with pip tool. pip install tqdm pytest python import relies on environment path variable: import sys print( sys.path )","title":"Developper tools"},{"location":"basis-03-dev/#developper-tools","text":"","title":"Developper tools"},{"location":"basis-03-dev/#python-a-modular-tool","text":"resources: myOwnPkg.py def myWonderfullFunction( aFirstIntergerPaprameter, aSecondIntergerParameters ) intergerSum= aFirstIntergerPaprameter + aSecondIntergerParameters return intergerSum script: myOwnCommand.py import myOwnPkg ... b= myOwnPkg.myWonderfullFunction( a, 40 ) ...","title":"Python, a Modular tool"},{"location":"basis-03-dev/#python-a-modular-tool_1","text":"Python packages are easy to install with pip tool. pip install tqdm pytest python import relies on environment path variable: import sys print( sys.path )","title":"Python, a Modular tool"},{"location":"dev-00-cairo/","text":"Graphic Interlude with Cairo This tutorial is a short parenthesis to present cairo one of the numerous libraries allowing drawing. Cairo is a library written in C , dedicated to vectorial 2D drawing. As with all C libraries, it is simple to port Cairo to other programming languages and to Python in particular. 1. Get started: In follow, a simple example is drawing a line, a rectangle. a triangle and a circle. The Cairo Python package can be installed with pip ( pip install pycairo ). import cairo, math filePath= \"drawing.png\" canvas= cairo.ImageSurface( cairo.Format.RGB24, 600, 400 ) context= cairo.Context( canvas ) # A Line context.move_to( 0, 0 ) context.line_to( 200, 100 ) context.set_line_width( 4 ) context.set_source_rgb( 0.6, 1 , 0 ) context.stroke() # A Rectangle : context.move_to( 100, 110 ) context.line_to( 500, 110 ) context.line_to( 500, 290 ) context.line_to( 100, 290 ) context.close_path() context.set_line_width( 3 ) context.set_source_rgb( 0.7, 0.7, 1.0 ) context.fill_preserve() context.set_source_rgb( 0, 0.1 , 0.8 ) context.stroke() # A triangle : context.move_to( 300, 180 ) context.line_to( 350, 220 ) context.line_to( 250, 220 ) context.close_path() context.set_source_rgb( 0, 0.1 , 0.8 ) context.fill() # A triangle : context.arc(450, 150, 20, 0, 2.0*math.pi) context.set_source_rgb( 0.8, 0.1 , 0 ) context.stroke() canvas.write_to_png( filePath ) Notice the particular syntax. First you move your context (a kind of pencil) on a surface, then you fill and/or stroke the shape you drawn. Filling or stroking also erases the 'pencil' movement, except if you use preserve functions. 2. Ressource: Pip page: pypi.org/project/pycairo Official page: cairographics.org Python tutorial: on tortall.net 3. Play with it: Try to draw something relaxing, a tree for instance.","title":"Graphic Interlude"},{"location":"dev-00-cairo/#graphic-interlude-with-cairo","text":"This tutorial is a short parenthesis to present cairo one of the numerous libraries allowing drawing. Cairo is a library written in C , dedicated to vectorial 2D drawing. As with all C libraries, it is simple to port Cairo to other programming languages and to Python in particular.","title":"Graphic Interlude with Cairo"},{"location":"dev-00-cairo/#1-get-started","text":"In follow, a simple example is drawing a line, a rectangle. a triangle and a circle. The Cairo Python package can be installed with pip ( pip install pycairo ). import cairo, math filePath= \"drawing.png\" canvas= cairo.ImageSurface( cairo.Format.RGB24, 600, 400 ) context= cairo.Context( canvas ) # A Line context.move_to( 0, 0 ) context.line_to( 200, 100 ) context.set_line_width( 4 ) context.set_source_rgb( 0.6, 1 , 0 ) context.stroke() # A Rectangle : context.move_to( 100, 110 ) context.line_to( 500, 110 ) context.line_to( 500, 290 ) context.line_to( 100, 290 ) context.close_path() context.set_line_width( 3 ) context.set_source_rgb( 0.7, 0.7, 1.0 ) context.fill_preserve() context.set_source_rgb( 0, 0.1 , 0.8 ) context.stroke() # A triangle : context.move_to( 300, 180 ) context.line_to( 350, 220 ) context.line_to( 250, 220 ) context.close_path() context.set_source_rgb( 0, 0.1 , 0.8 ) context.fill() # A triangle : context.arc(450, 150, 20, 0, 2.0*math.pi) context.set_source_rgb( 0.8, 0.1 , 0 ) context.stroke() canvas.write_to_png( filePath ) Notice the particular syntax. First you move your context (a kind of pencil) on a surface, then you fill and/or stroke the shape you drawn. Filling or stroking also erases the 'pencil' movement, except if you use preserve functions.","title":"1. Get started:"},{"location":"dev-00-cairo/#2-ressource","text":"Pip page: pypi.org/project/pycairo Official page: cairographics.org Python tutorial: on tortall.net","title":"2. Ressource:"},{"location":"dev-00-cairo/#3-play-with-it","text":"Try to draw something relaxing, a tree for instance.","title":"3. Play with it:"},{"location":"dev-01-pack/","text":"Python packaging. Until now, all our Python components have been defined in a unique file scene2d.py . By growing in complexity, most of the project relies on several source files. Then your Python package would be all the content of an entire directory. Here, the goal would be to create shape classes, in our scene2d packages. 1. Classical package strucure Classically the package is in a source (src) directory. It is composed with __init__.py files defined (potentially empty) in each pkg directory. This file marks a Python package. It would also be the imported file when you will import pkg . workspace src \u2514\u2500\u2500 pkg \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 module1.py \u2514\u2500\u2500 subpkg \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 module2.py In our case it should be : scene-prj src \u2514\u2500\u2500 scene2d \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 camera.py Naturally, the Camera class should be defined on camera.py . 2. local import Inside the package, it is possible to use local imports. Imports based on '.' this position '..' the parent position. For instance, a from . import camera will import the content of camera.py . This way, the __init__.py file can redefine the Camera to make it available from an import of scene2d . from . import camera Camera= camera.Camera At this point, Pytest should work again just by changing import scene2d by import src.scene2d in the test files. Implement Shapes Ask the teacher...","title":"Packaging"},{"location":"dev-01-pack/#python-packaging","text":"Until now, all our Python components have been defined in a unique file scene2d.py . By growing in complexity, most of the project relies on several source files. Then your Python package would be all the content of an entire directory. Here, the goal would be to create shape classes, in our scene2d packages.","title":"Python packaging."},{"location":"dev-01-pack/#1-classical-package-strucure","text":"Classically the package is in a source (src) directory. It is composed with __init__.py files defined (potentially empty) in each pkg directory. This file marks a Python package. It would also be the imported file when you will import pkg . workspace src \u2514\u2500\u2500 pkg \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 module1.py \u2514\u2500\u2500 subpkg \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 module2.py In our case it should be : scene-prj src \u2514\u2500\u2500 scene2d \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 camera.py Naturally, the Camera class should be defined on camera.py .","title":"1. Classical package strucure"},{"location":"dev-01-pack/#2-local-import","text":"Inside the package, it is possible to use local imports. Imports based on '.' this position '..' the parent position. For instance, a from . import camera will import the content of camera.py . This way, the __init__.py file can redefine the Camera to make it available from an import of scene2d . from . import camera Camera= camera.Camera At this point, Pytest should work again just by changing import scene2d by import src.scene2d in the test files. Implement Shapes Ask the teacher...","title":"2. local import"},{"location":"dev-02-tools/","text":"Develloper's tools The idea here is to present briefly the main tools in the developer toolbox. It is mainly a question of Versionning and Test-Driven-Devellopement . In some way, they are philosophical tools. Their main reliance is on good practices (and a little on dedicated software). Versionning tell you that you should adopt a developer behavior allowing you to keep the history of the development process (successive code changes). At any time, you should be capable of returning the project to any previous state. Test-Driven-Devellopement tell you that you should first develop the tests of the functionality before to implement it. This way you start from an example of how to use it and which results the functionality should generate. Those two philosophies allow you to work in complete security. You can try things that could break everything. Tests will help in the repairing process, or versions will allow you to return to a working state. Naturally those philosophies come with software-tools to deploy. You have, for instance, Git for Versionning and Pytest for Test-Driven-Devellopement . 1. Versionning So the idea is to keep traces of code changes. But first, it starts with a project. The idea is to create a Python package (let's say scene2d), that represents a 2-dimensional vectorial scene. I.e. a collection of shapes (points, lines, polygons, ...). 1.a Project initialization So first, we are required to create our project, with a scene-prj directory, a README.md file inside including a brief description of what we are attempting to do, and a scene2d.py file for our new Python package. This is our initial state. And we want to save it. To achieve it, we will use git : Official webpage: git-scm.com On Windows, typically: git-scm.com or gitforwindows.org And some basis in less than 30 minutes: git-scm.com/videos So, with your favorite shell, you initialize a git repository: cd scene-prj ls . | README.md scene2d.py cat README.md | # Scene2d | | A python package to model a 2 dimentional scene as a collection of shapes. git init . As Git informs you, Git works with different branches. Each branch matches a specific version of the project. Typically you can have master for the main branch shared with all the users, beta for the beta-test version, and dev for the in-development branch. You can also have a branch per target: window , linux or mac a branch per contributor in the project, etc. By default, git init creates a unique empty branch: master . The command git status allows developers to get the status of the repository (a repository can be seen as a versioned directory). At this time, status should state that README.md and scene2d.py are not included to keep changes. We should add them, and commit to recording those new files and their content. git add README.md scene2d.py git commit Potentially, this command requires some information about the author. You should provide them as recommended and commit again. The commit command opens an editor to allow you to define a commit message. Here you can write \"initial commit\" and save. Those messages serve to remember the status of the project at commit time. Finally, the command log permits listing the history of commits. Only one for now. git log | commit a6e5dc1b0fd47f22416e66787dd6c13f8b365fdd (HEAD -> master) | Author: guillaumeLozenguez <guillaume@drods.net> | Date: Tue Oct 7 16:57:42 2025 +0200 | | initial commit 1.b The Camera Class As a first functionality, the scene2d project should be capable of drawing different shapes. However, our scene should be defined in a Cartesian space, with floating-point values. By opposition, the drawing is in pixels. Furthermore, the Cartesian basis of our scene is not necessarily the same as in the drawing. We imagine including that functionality into a class Camara defined with a scale (a number of pixels per scene unit - meters for instance) and position . So we initialize such a new class in our scene2d.py . class Camera : def __init__(self) self._scale= 10 self._position_x= 0.0 self._position_y= 0.0 At this point, a git status should inform us that the file scene2d.py is modified. If you want to record those modifications, we should add again scene2d.py to be included in the next commit then commit. A short way to do that is to use a add-all option ( -a ). It is also possible to feed the commit with the commit message, by using the option -m . So : git commit -a -m \"new Camera class\" For a complete description of commit options, see git-scm.com/docs . Now the git log command should state 2 commits. Notice that each commit comes with an identifier, a6e5dc1b0fd47f22416e66787dd6c13f8b365fdd in my case, for the first commit. This identifier allows you to retrieve previous versions of your code. For instance, with a : git checkout a6e5dc1b0 my scene2d.py is empty, as in my initial commit. A git checkout master returns the code in the last version in the timeline on the master branch (our unique branch at this point). For more about Git , you can search all the Git commands at git-scm.com/docs . 2. Test-Driven Devellopement Define test-cases before to code. The main idea of develloping program is to implement functionalities incrementally to allow our program to grow in complexity. With tests, you create scripts that will test each of your functionalities in any direction possible. Test-Driven Development ( TDD ) goes further. It invites developers to create the tests before creating a functionality. This process, in this order, forces the developers to clearly define a context of execution for the desired functionality. More on TDD on wikipedia.org . Professor's advice: It seems to cost you a lot at the beginning to create a test before of the functionality. In fact, in a professional life, developing TDD reflexes will save you and your team many times. 2.a Get Started Again, Python comes with several tools for automatic testing. Here we propose to use pytest . For a complete introduction of the tool, see wikipedia.org . Pytest can be installed with pip (what a surprise...). By default, tests are implemented on specific Python test files. Those files will always be named as test_something.py . This way, pytest will recognize those files as resources to test. To notice that pytest will test all test_...py files in an alphabetic order. So we recommend adopting specific naming rules to control the order the tests are executed. Let start with a first test file test_01_package.py . This test tests the existence of our package and its components. Tests are Python functions with no argument. As for file names, function names should start with test_ . Exemple for our test_01_package.py . def test_import(): import scene2d import scene2d def test_camera(): camera= scene2d.Camera() You can test a specific file with pytest test_01_package.py or an entire directory tree with pytest alone. Pytest also accepts arguments, such as -x to stop on the first failure. At this point, test should fail. A : is missing after def __init__(self) of the Camera class. Correct the file and try again. You can commit after adding test_01_package.py with a commit message: 'first tests' . In fact, you can commit as often as possible. Git records only modifications in the files, and frequent commits will not cost a lot more space than rare commits. 2.b Frame transform So the first functionality of our camera is to be capable of transforming coordinates in the scene into pixels in the drawing. As a first approximation, the test can be worded in usual english: It is possible to define a Camera. The Camera has a drawing surface (by default 600x400). The Camera has a position (by default (0, 0) ). (The position points the location in the center of the image) So transforming origin position should retrun (300, 200). The Camera has a scale (number of pixel per scene unit). The default scale is 10 pixels. So the transfrom of (1.0, 1.0) should be (310, 190) (y-axis is in the oposit direction in a drawing). To define this test, we will use the assert instruction. Assert is a built-in instruction in Python , testing for a condition, and stopping the execution of the program if the condition is false (failure). Example in w3schools.com . So, our new test_02_camera.py will be: def test_defaultCamera(): camera= scene2d.Camera() assert type(camera) == scene2d.Camera x, y= camera.position() assert (x, y) == (0.0, 0.0) assert camera.scale() == 10 def test_defaultTransform(): camera= scene2d.Camera() assert camera.pixel(0.0, 0.0) == (300, 200) assert camera.pixel(0.0, 0.0) == (310, 190) At this point, pytest -x should fail. The first error is that the position method is not implemented. To leverage this error, we can implement this method by returning the coordinates. The second error will point to the scale accessor method, etc. At the end of this debugging process, your code should not fail in any way. This will indicate you terminate to implement the functionality. It is a good time to commit. Before going on to another functionality, it is possible to add more tests to validate that, the transformation operates with different camera positions and scalings. That's supposed to test the possibility to modify the camera attributes and that the transform computations remain ok. 2.b Drawing For a complete Camera class, we suppose the capability to effectively draw some vector-graphics in a file (based on the cairo librairy for instance). It is possible to instanciate a Camera. The camera point to a file ('output.png' by default). It is possible to use the Camera to draw a line. It is possible to use the Camera to draw the frame basis. So, in a new test_03_drawing.py file: def test_drawLine(): camera= scene2d.Camera() assert camera.file() == \"output.png\" camera.drawLine( (-3.0, -5.0), (3.0, 5.0) ) camera.save() outputFile= open( \"output.png\", mode='rb' ).read() refsFile= open( \"resources/02-line.png\", mode='rb' ).read() assert shotFile == refsFile def test_drawBasis(): camera= scene2d.Camera() camera.setPosition( 2.0, 1.5 ) camera.setScale( 50 ) camera.drawBasis() camera.save() outputFile= open( \"output.png\", mode='rb' ).read() refsFile= open( \"resources/02-basis.png\", mode='rb' ).read() assert shotFile == refsFile The tests mainly rely on comparing .png bitmap. To do that, we open the bitmap in read bit mode and perform a comparison. Potentially, the test fails because the test is wrong. In our case, at some point, the tests should fails on open(\"resources/02-line.png\") . When you are satisfied with the generated output.png (a beautiful black line under a white background, for instance), then you copy-paste this file as 02-line.png into a new resources directory. Pytest should pass to the next failure. In other words, defining the tests helps you in the process of implementing the functionality. However, the test implementation can evolve with the implementation of the functionnality. Is everything ok ? Then commit. Attention, the output.png file should not be included in your Git repository. This file is generated, there is no need to save it. Look at gitignore to do that properly. 2.c Go on... Let apply this methodology (define a test and use the test to implement a functionality) for several more functionalities: Drawing polydones and circles. Changing the drawing color (stroke and/or fill colors). 3. Debugging Investigate debugging tools is out of the scope of this lecture. However you can see : What your favorite editor is capable of: code.visualstudio.com . The Python debugger lib: pdb And potentially a Python profiler . At our level, we just expect good behavior: In case of a bug, it is expected to isolate the bug. So first, create a new test-case that reproduces the detected problem. At this step, the test should fail. Commit. Then, correct the bug. Commit. This way you continuously improve your test-pool and you guarantee clean future developments. If any modification in the code generates again a bug already encountered, this bug will be automatically detected.","title":"Develloper tools"},{"location":"dev-02-tools/#devellopers-tools","text":"The idea here is to present briefly the main tools in the developer toolbox. It is mainly a question of Versionning and Test-Driven-Devellopement . In some way, they are philosophical tools. Their main reliance is on good practices (and a little on dedicated software). Versionning tell you that you should adopt a developer behavior allowing you to keep the history of the development process (successive code changes). At any time, you should be capable of returning the project to any previous state. Test-Driven-Devellopement tell you that you should first develop the tests of the functionality before to implement it. This way you start from an example of how to use it and which results the functionality should generate. Those two philosophies allow you to work in complete security. You can try things that could break everything. Tests will help in the repairing process, or versions will allow you to return to a working state. Naturally those philosophies come with software-tools to deploy. You have, for instance, Git for Versionning and Pytest for Test-Driven-Devellopement .","title":"Develloper's tools"},{"location":"dev-02-tools/#1-versionning","text":"So the idea is to keep traces of code changes. But first, it starts with a project. The idea is to create a Python package (let's say scene2d), that represents a 2-dimensional vectorial scene. I.e. a collection of shapes (points, lines, polygons, ...).","title":"1. Versionning"},{"location":"dev-02-tools/#1a-project-initialization","text":"So first, we are required to create our project, with a scene-prj directory, a README.md file inside including a brief description of what we are attempting to do, and a scene2d.py file for our new Python package. This is our initial state. And we want to save it. To achieve it, we will use git : Official webpage: git-scm.com On Windows, typically: git-scm.com or gitforwindows.org And some basis in less than 30 minutes: git-scm.com/videos So, with your favorite shell, you initialize a git repository: cd scene-prj ls . | README.md scene2d.py cat README.md | # Scene2d | | A python package to model a 2 dimentional scene as a collection of shapes. git init . As Git informs you, Git works with different branches. Each branch matches a specific version of the project. Typically you can have master for the main branch shared with all the users, beta for the beta-test version, and dev for the in-development branch. You can also have a branch per target: window , linux or mac a branch per contributor in the project, etc. By default, git init creates a unique empty branch: master . The command git status allows developers to get the status of the repository (a repository can be seen as a versioned directory). At this time, status should state that README.md and scene2d.py are not included to keep changes. We should add them, and commit to recording those new files and their content. git add README.md scene2d.py git commit Potentially, this command requires some information about the author. You should provide them as recommended and commit again. The commit command opens an editor to allow you to define a commit message. Here you can write \"initial commit\" and save. Those messages serve to remember the status of the project at commit time. Finally, the command log permits listing the history of commits. Only one for now. git log | commit a6e5dc1b0fd47f22416e66787dd6c13f8b365fdd (HEAD -> master) | Author: guillaumeLozenguez <guillaume@drods.net> | Date: Tue Oct 7 16:57:42 2025 +0200 | | initial commit","title":"1.a Project initialization"},{"location":"dev-02-tools/#1b-the-camera-class","text":"As a first functionality, the scene2d project should be capable of drawing different shapes. However, our scene should be defined in a Cartesian space, with floating-point values. By opposition, the drawing is in pixels. Furthermore, the Cartesian basis of our scene is not necessarily the same as in the drawing. We imagine including that functionality into a class Camara defined with a scale (a number of pixels per scene unit - meters for instance) and position . So we initialize such a new class in our scene2d.py . class Camera : def __init__(self) self._scale= 10 self._position_x= 0.0 self._position_y= 0.0 At this point, a git status should inform us that the file scene2d.py is modified. If you want to record those modifications, we should add again scene2d.py to be included in the next commit then commit. A short way to do that is to use a add-all option ( -a ). It is also possible to feed the commit with the commit message, by using the option -m . So : git commit -a -m \"new Camera class\" For a complete description of commit options, see git-scm.com/docs . Now the git log command should state 2 commits. Notice that each commit comes with an identifier, a6e5dc1b0fd47f22416e66787dd6c13f8b365fdd in my case, for the first commit. This identifier allows you to retrieve previous versions of your code. For instance, with a : git checkout a6e5dc1b0 my scene2d.py is empty, as in my initial commit. A git checkout master returns the code in the last version in the timeline on the master branch (our unique branch at this point). For more about Git , you can search all the Git commands at git-scm.com/docs .","title":"1.b The Camera Class"},{"location":"dev-02-tools/#2-test-driven-devellopement","text":"Define test-cases before to code. The main idea of develloping program is to implement functionalities incrementally to allow our program to grow in complexity. With tests, you create scripts that will test each of your functionalities in any direction possible. Test-Driven Development ( TDD ) goes further. It invites developers to create the tests before creating a functionality. This process, in this order, forces the developers to clearly define a context of execution for the desired functionality. More on TDD on wikipedia.org . Professor's advice: It seems to cost you a lot at the beginning to create a test before of the functionality. In fact, in a professional life, developing TDD reflexes will save you and your team many times.","title":"2. Test-Driven Devellopement"},{"location":"dev-02-tools/#2a-get-started","text":"Again, Python comes with several tools for automatic testing. Here we propose to use pytest . For a complete introduction of the tool, see wikipedia.org . Pytest can be installed with pip (what a surprise...). By default, tests are implemented on specific Python test files. Those files will always be named as test_something.py . This way, pytest will recognize those files as resources to test. To notice that pytest will test all test_...py files in an alphabetic order. So we recommend adopting specific naming rules to control the order the tests are executed. Let start with a first test file test_01_package.py . This test tests the existence of our package and its components. Tests are Python functions with no argument. As for file names, function names should start with test_ . Exemple for our test_01_package.py . def test_import(): import scene2d import scene2d def test_camera(): camera= scene2d.Camera() You can test a specific file with pytest test_01_package.py or an entire directory tree with pytest alone. Pytest also accepts arguments, such as -x to stop on the first failure. At this point, test should fail. A : is missing after def __init__(self) of the Camera class. Correct the file and try again. You can commit after adding test_01_package.py with a commit message: 'first tests' . In fact, you can commit as often as possible. Git records only modifications in the files, and frequent commits will not cost a lot more space than rare commits.","title":"2.a Get Started"},{"location":"dev-02-tools/#2b-frame-transform","text":"So the first functionality of our camera is to be capable of transforming coordinates in the scene into pixels in the drawing. As a first approximation, the test can be worded in usual english: It is possible to define a Camera. The Camera has a drawing surface (by default 600x400). The Camera has a position (by default (0, 0) ). (The position points the location in the center of the image) So transforming origin position should retrun (300, 200). The Camera has a scale (number of pixel per scene unit). The default scale is 10 pixels. So the transfrom of (1.0, 1.0) should be (310, 190) (y-axis is in the oposit direction in a drawing). To define this test, we will use the assert instruction. Assert is a built-in instruction in Python , testing for a condition, and stopping the execution of the program if the condition is false (failure). Example in w3schools.com . So, our new test_02_camera.py will be: def test_defaultCamera(): camera= scene2d.Camera() assert type(camera) == scene2d.Camera x, y= camera.position() assert (x, y) == (0.0, 0.0) assert camera.scale() == 10 def test_defaultTransform(): camera= scene2d.Camera() assert camera.pixel(0.0, 0.0) == (300, 200) assert camera.pixel(0.0, 0.0) == (310, 190) At this point, pytest -x should fail. The first error is that the position method is not implemented. To leverage this error, we can implement this method by returning the coordinates. The second error will point to the scale accessor method, etc. At the end of this debugging process, your code should not fail in any way. This will indicate you terminate to implement the functionality. It is a good time to commit. Before going on to another functionality, it is possible to add more tests to validate that, the transformation operates with different camera positions and scalings. That's supposed to test the possibility to modify the camera attributes and that the transform computations remain ok.","title":"2.b Frame transform"},{"location":"dev-02-tools/#2b-drawing","text":"For a complete Camera class, we suppose the capability to effectively draw some vector-graphics in a file (based on the cairo librairy for instance). It is possible to instanciate a Camera. The camera point to a file ('output.png' by default). It is possible to use the Camera to draw a line. It is possible to use the Camera to draw the frame basis. So, in a new test_03_drawing.py file: def test_drawLine(): camera= scene2d.Camera() assert camera.file() == \"output.png\" camera.drawLine( (-3.0, -5.0), (3.0, 5.0) ) camera.save() outputFile= open( \"output.png\", mode='rb' ).read() refsFile= open( \"resources/02-line.png\", mode='rb' ).read() assert shotFile == refsFile def test_drawBasis(): camera= scene2d.Camera() camera.setPosition( 2.0, 1.5 ) camera.setScale( 50 ) camera.drawBasis() camera.save() outputFile= open( \"output.png\", mode='rb' ).read() refsFile= open( \"resources/02-basis.png\", mode='rb' ).read() assert shotFile == refsFile The tests mainly rely on comparing .png bitmap. To do that, we open the bitmap in read bit mode and perform a comparison. Potentially, the test fails because the test is wrong. In our case, at some point, the tests should fails on open(\"resources/02-line.png\") . When you are satisfied with the generated output.png (a beautiful black line under a white background, for instance), then you copy-paste this file as 02-line.png into a new resources directory. Pytest should pass to the next failure. In other words, defining the tests helps you in the process of implementing the functionality. However, the test implementation can evolve with the implementation of the functionnality. Is everything ok ? Then commit. Attention, the output.png file should not be included in your Git repository. This file is generated, there is no need to save it. Look at gitignore to do that properly.","title":"2.b Drawing"},{"location":"dev-02-tools/#2c-go-on","text":"Let apply this methodology (define a test and use the test to implement a functionality) for several more functionalities: Drawing polydones and circles. Changing the drawing color (stroke and/or fill colors).","title":"2.c Go on..."},{"location":"dev-02-tools/#3-debugging","text":"Investigate debugging tools is out of the scope of this lecture. However you can see : What your favorite editor is capable of: code.visualstudio.com . The Python debugger lib: pdb And potentially a Python profiler . At our level, we just expect good behavior: In case of a bug, it is expected to isolate the bug. So first, create a new test-case that reproduces the detected problem. At this step, the test should fail. Commit. Then, correct the bug. Commit. This way you continuously improve your test-pool and you guarantee clean future developments. If any modification in the code generates again a bug already encountered, this bug will be automatically detected.","title":"3. Debugging"},{"location":"dev-03-integ/","text":"Integration Python project. pip. pyproject file and pipy... Packaging Python Projects","title":"Integration"},{"location":"dev-03-integ/#integration","text":"Python project. pip. pyproject file and pipy... Packaging Python Projects","title":"Integration"}]}